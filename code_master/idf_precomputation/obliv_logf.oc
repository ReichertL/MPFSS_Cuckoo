#include "obliv.oh"
#include "obliv_logf.oh"

// Reinterprets an obliv int32 as an obliv float.
obliv float oint_as_ofloat(obliv int32_t in) obliv {
  obliv float* ofptr = (obliv float*)&in;
  return *ofptr;
}

// Reinterprets an obliv float as an obliv int32.
obliv int32_t ofloat_as_oint(obliv float in) obliv {
  obliv int32_t* oiptr = (obliv int32_t*)&in;
  return *oiptr;
}

// Converts an obliv int to an obliv float.
// Based on https://stackoverflow.com/a/20308114
obliv float oint_to_ofloat(obliv int32_t in_signed) obliv {
  obliv float result = 0.0;
  obliv bool negative = (in_signed < 0);
  obliv if (negative) { in_signed = 0 - in_signed; }
  obliv if (in_signed > 0) {
    obliv uint32_t in = in_signed;
    obliv uint8_t shifts = 0;
    obliv bool shifts_done = false;
    for (size_t i = 0; i < 32; i++) {
      obliv if ((in & (1 << 31)) == 0) {
        obliv if (shifts_done == false) {
          in <<= 1;
          shifts++;
        }
      }
      else {
        shifts_done = true;
      }
    }
    obliv uint8_t exponent = 127 + 31 - shifts;
    obliv uint32_t merged =
        (((obliv uint32_t)exponent) << 23) | ((in >> (31 - 23)) & 0x7FFFFF);
    result = *((obliv float*)&merged);
  }
  obliv if (negative) { result = 0 - result; }
  return result;
}

obliv float obliv_fmaf(obliv float x, obliv float y, obliv float z) obliv {
  return x * y + z;
}

// Natural logarithm approximation.
// Based on https://stackoverflow.com/a/39822314
obliv float obliv_logf(obliv float a) {
  obliv float m, r, s, t, i, f;
  obliv int32_t e;

  obliv if ((a > 0.0f) & (a <= 3.40282347e+38f)) {  // 0x1.fffffep+127
    i = 0.0f;
    /* fix up denormal inputs */
    obliv if (a < 1.175494351e-38f) {  // 0x1.0p-126
      a = a * 8388608.0f;              // 0x1.0p+23
      i = -23.0f;
    }
    e = (ofloat_as_oint(a) - 0x3f2aaaab) & 0xff800000;
    m = oint_as_ofloat(ofloat_as_oint(a) - e);
    i = obliv_fmaf(oint_to_ofloat(e), 1.19209290e-7f, i);  // 0x1.0p-23
    /* m in [2/3, 4/3] */
    f = m - 1.0f;
    s = f * f;
    /* Compute log1p(f) for f in [-1/3, 1/3] */
    r = obliv_fmaf(-0.130187988f, f,
                   0.140889585f);  // -0x1.0aa000p-3, 0x1.208ab8p-3
    t = obliv_fmaf(-0.121489584f, f,
                   0.139809534f);  // -0x1.f19f10p-4, 0x1.1e5476p-3
    r = obliv_fmaf(r, s, t);
    r = obliv_fmaf(r, f, -0.166845024f);  // -0x1.55b2d8p-3
    r = obliv_fmaf(r, f, 0.200121149f);   //  0x1.99d91ep-3
    r = obliv_fmaf(r, f, -0.249996364f);  // -0x1.fffe18p-3
    r = obliv_fmaf(r, f, 0.333331943f);   //  0x1.5554f8p-2
    r = obliv_fmaf(r, f, -0.500000000f);  // -0x1.000000p-1
    r = obliv_fmaf(r, s, f);
    r = obliv_fmaf(i, 0.693147182f, r);  //   0x1.62e430p-1 // log(2)
  }
  else {
    r = a + a;  // silence NaNs if necessary
    obliv if (a < 0.0f) {
      r = 0.0f / 0.0f;  //  NaN
    }
    obliv if (a == 0.0f) {
      r = -1.0f / 0.0f;  // -Inf
    }
  }
  return r;
}