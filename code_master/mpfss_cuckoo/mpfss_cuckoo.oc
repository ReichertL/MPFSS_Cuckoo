#include <stdlib.h>
#include <stdint.h>

#include <obliv.oh>
#include <copy.oh>
#include <obig.oh>
#include <osort.oh>


#include "dbg.h"
#include "mpfss_naive.h"
#include "mpfss_naive.oh"
#include "mpfss_cuckoo.oh"
#include "create_structs.h"
#include "create_structs.oh"



void call_dpf_from_matches(match **matches,bool **dpf_vectors,
	uint8_t *** dpf_value_vectors, mpfss_cuckoo *m, int *bucket_lenghts, 
	bool set_beta, uint8_t **beta_value_vector, 
	uint8_t *beta_skalar_no,
	bool cprg){

	//synchronize	
	if(ocCurrentParty()==1){
		ocBroadcastInt(1, 1);
	}else{
		int ok=3;
		while(!( ok==1)){
			ok= ocBroadcastInt(1, 1);
		}
	}

	int count=0;
	for (int i = 0; i < m->b; ++i){
		int index_non_obliv;  		
		if(ocCurrentParty()==1){
  			index_non_obliv=(size_t)matches[i]->index_in_bucket;
  			debug("index_non_obliv %d\n", index_non_obliv);
  			if(index_non_obliv==-1){
  				debug("empty batch!\n");
  			}
  		}

	  	bool *local_bit_output;
	  	uint8_t *local_output;

	  	if(set_beta){
		  	uint8_t *beta_value_no;
		  	if(ocCurrentParty()==1 && index_non_obliv!=-1){
		  		beta_value_no = beta_value_vector[count];
		  		count++;
		  	}else if(ocCurrentParty()==1 && index_non_obliv==-1){
		  		beta_value_no=(uint8_t *) calloc(memblocksize, sizeof(uint8_t)); 
		  	}else{
		  		beta_value_no=NULL;
		  	}

		  	obliv uint8_t *beta_value=calloc(1, memblocksize * sizeof(obliv uint8_t));
			feedOblivLLongArray((obliv uint64_t *)beta_value, (uint64_t *) beta_value_no,  memblocksize/sizeof(uint64_t), 1);
	
			obliv uint8_t *beta_skalar=calloc(memblocksize, sizeof(obliv uint8_t));
			feedOblivLLongArray((obliv uint64_t *)beta_skalar, (uint64_t *) beta_skalar_no,  memblocksize/sizeof(uint64_t), 2);

			obig prod;	
			obig obig_s;
			obig obig_b;

			obig_init(&prod, memblocksize);
			obig_init(&obig_s, memblocksize);
			obig_init(&obig_b, memblocksize);

			obig_import_opointed_be(&obig_s, beta_skalar, memblocksize );
			obig_import_opointed_be(&obig_b, beta_value, memblocksize );
			obig_mul(&prod, obig_s, obig_b);		

			obliv uint8_t *xor_prod=calloc(memblocksize, sizeof(obliv uint8_t));
			obig_export_opointed_be(xor_prod,memblocksize, &prod);

			dpf_with_beta( 		(size_t) bucket_lenghts[i],
								index_non_obliv, 
								xor_prod, 
								i,  									
								&local_bit_output,
								&local_output,
								cprg);	
			
			if(ocCurrentParty()==1 && index_non_obliv==-1){
				free(beta_value_no);
			}

			free(beta_value);
			free(beta_skalar);
			free(xor_prod);
			obig_free(&obig_s);
			obig_free(&obig_b);
			obig_free(&prod);

	  	}else{
	  		obliv uint8_t *active_block_delta;
		  	dpf_proper( bucket_lenghts[i],
						index_non_obliv,
						&active_block_delta,
						i,  
						&local_bit_output,
						&local_output,
						cprg);
		  	free(active_block_delta);
		}				
	  	
		dpf_vectors[i]=local_bit_output;
		dpf_value_vectors[i]=local_output;
	}


	#ifdef DEBUG
		debug("------------- RESUTLS -------------\n");
	  	for(int i=0; i<m->b; i++){
	  		
			/*int bucketsize=bucket_lenghts[i];

			obliv bool *v1= calloc(bucketsize, sizeof(obliv bool));
			obliv bool *v2= calloc(bucketsize, sizeof(obliv bool));
			feedOblivBoolArray(v1, dpf_vectors[i], bucketsize, 1);
			feedOblivBoolArray(v2, dpf_vectors[i], bucketsize, 2);;

			obliv bool *dpf_obliv= calloc(bucketsize, sizeof(obliv bool));
			for(int i = 0; i <bucketsize ; i++) {
				dpf_obliv[i]=v1[i]^v2[i]; 
			}
			free(v1);
			free(v2);

			bool *vdpf2= calloc(bucketsize, sizeof(bool));
			revealOblivBoolArray(vdpf2, dpf_obliv, bucketsize, 0);
			free(dpf_obliv);

			char *buff=calloc(bucketsize*2+100, sizeof(int));
			sprintf(buff, "dpf #%d:               ", i);  
			for(int j = 0; j <bucketsize; j++) {
				char r[1+ sizeof(int)];
				sprintf(r, " %d", vdpf2[j]);		
			  	strcat(buff, r );  
			}
			debug("%s\n",buff);
			free(buff);
			free(vdpf2);*/

			//----
			/*int size=bucket_lenghts[i];
			uint8_t *local_output_1=calloc(1, size* memblocksize*sizeof(obliv uint8_t));
			uint8_t *local_output_2=calloc(1, size* memblocksize*sizeof(obliv uint8_t));
			ocBroadcastLLongArray((uint64_t *)local_output_1, (uint64_t *)dpf_value_vectors[i], size*memblocksize/sizeof(uint64_t), 1);
			ocBroadcastLLongArray((uint64_t *)local_output_2, (uint64_t *)dpf_value_vectors[i],size*memblocksize/sizeof(uint64_t),  2);
			uint8_t *dpf_with_beta=calloc( size, sizeof(uint8_t)* memblocksize);
			for (size_t ii = 0; ii< size; ii++) {
				for (size_t jj = 0; jj < memblocksize; jj++) {
					uint8_t xor=  local_output_1[ii * memblocksize + jj]^ local_output_2[ii * memblocksize + jj];
					dpf_with_beta[ii * memblocksize + jj]=xor;
				}
			}
			free(local_output_1);
			free(local_output_2);

			char *buff = (char *) calloc((int)size *40*memblocksize+100, sizeof(int));
			sprintf(buff, "dpf_with_values! %d\n", i);  
			for(int ii = 0; ii <size ; ii++) {
				for (int jj=0;jj<memblocksize; ++jj){
					char r[10*sizeof(int)];	
					sprintf(r, " %d", dpf_with_beta[ii * memblocksize + jj]);	
				  	strcat(buff, r );  
				}	
				char *eof="\n";	
				strcat(buff, eof );
			}
			debug("%s\n",buff);
			free(buff);
			free(dpf_with_beta);*/
			
	  	}
  	#endif 
}


bool *reveal_vector(bool *vector, int vector_size, int print){

	obliv bool *v1= calloc(vector_size, sizeof(obliv bool));
	obliv bool *v2= calloc(vector_size, sizeof(obliv bool));
	feedOblivBoolArray(v1, vector, vector_size, 1);
	feedOblivBoolArray(v2, vector, vector_size, 2);

	obliv bool *dpf_obliv= calloc(vector_size, sizeof(obliv bool));
	for(int i = 0; i <vector_size ; i++) {
			dpf_obliv[i]=v1[i]^v2[i]; 
	}    
	free(v1);
	free(v2);
	
	bool *reveald_vector= calloc(vector_size, sizeof(bool));
	revealOblivBoolArray(reveald_vector, dpf_obliv, vector_size, 0);
	free(dpf_obliv);

	if(print==1){

		char *buff=calloc(vector_size*2+100, sizeof(int));
		sprintf(buff, "Revealed Vector: ");  
		for(int j = 0; j <vector_size; j++) {
			char r[1+ sizeof(int)];
			sprintf(r, " %d", reveald_vector[j]);		
		  	strcat(buff, r );  
		}
		debug("%s\n",buff);
		log_info("%s\n",buff);
		free(buff);

	}
	return reveald_vector;
}

void create_mpfss_vector_cuckoo(bool *mpfss_bit_vector,uint8_t **mpfss_value_vector, bool **dpf_vectors, uint8_t ***dpf_value_vectors, int ** all_buckets_array, int *bucket_lenghts,  int size, int b){
    

    for(int i=0;i<b; i++){

    	int *bucket=all_buckets_array[i];
        int len=bucket_lenghts[i];

        for (int j=0; j<len;j++){

            bool is_set=dpf_vectors[i][j];
            int position=bucket[j];
            mpfss_bit_vector[position]=mpfss_bit_vector[position]^is_set;

            for (int k = 0; k < memblocksize; ++k){
            	uint8_t *vec=dpf_value_vectors[i];
            	uint8_t value=vec[j*memblocksize +k ];
        		mpfss_value_vector[position][k]^=value;
        	}
        }
    }

    /*#ifdef  INFO
        bool * v1=reveal_vector(mpfss_bit_vector, size, 1);  
        free(v1);
    #endif*/

    #ifdef DEBUG
        bool * v=reveal_vector(mpfss_bit_vector, size, 1);  


	        /*char filename[80];
	        sprintf(filename, "results_debug_mpfss_cuckoo_result.txt");

	        FILE *fptr;
	        fptr = fopen(filename,"w");

	        if(fptr == NULL){
	              printf("Error while opening results_debug_mpfss_cuckoo!");               
	        }else{

	        	fseek (fptr, 0, SEEK_END);
	        	int len = ftell(fptr);
	       	 	if (0 == len) {
	       	 		for (int i = 0; i < size; ++i){
	       	 			uint8_t *local_output_1=calloc(memblocksize, sizeof(uint8_t));
						uint8_t *local_output_2=calloc(memblocksize, sizeof(uint8_t));
						ocBroadcastLLongArray((uint64_t *)local_output_1, (uint64_t *)mpfss_value_vector[i], memblocksize/sizeof(uint64_t), 1);
						ocBroadcastLLongArray((uint64_t *)local_output_2, (uint64_t *)mpfss_value_vector[i],memblocksize/sizeof(uint64_t),  2);
						uint8_t *this_vector=calloc( memblocksize, sizeof(uint8_t));
						
						for (size_t jj = 0; jj < memblocksize; jj++) {
							uint8_t xor=  local_output_1[i * memblocksize + jj]^ local_output_2[i * memblocksize + jj];
							this_vector[i * memblocksize + jj]=xor;
						}
						
						free(local_output_1);
						free(local_output_2);
	       	 			char *buff=calloc(memblocksize+100, sizeof(int));
	       	 			for (int k = 0; k < memblocksize; ++k){    
						   	char r[10+ sizeof(int)];	
							sprintf(r, " %d", this_vector[k]);		
						  	strcat(buff, r ); 
						}
						
						if(ocCurrentParty()==1){
	            			fprintf(fptr,"%d, %s\n",v[i],buff );
	       	 			}
	       	 		}
	        	}
	    	}
	    	fclose(fptr);*/
        free(v);

        printf("MPFSS with Values \n");
        for (int i = 0; i < size; ++i){
        	for (int k = 0; k < memblocksize; ++k){
	            uint8_t value=mpfss_value_vector[i][k ];
	            uint8_t val1=ocBroadcastInt(value, 1);
	            uint8_t val2=ocBroadcastInt(value, 2);
	            printf("%d ",val1 ^val2);
        	}
        	printf("\n");
        }
    #endif
}


obliv int8_t cmp_pair_by_key(OcCopy *cpy, void *el1, void *el2) {
	obliv char ret=1;

	obliv if(((obliv int *) el1)[0] <  ((obliv int *) el2)[0]){
		ret=-1;
	}

	return ret;
	/*__obliv_c__setLessThanUnsigned(&el1_is_less, ((match_ext)el1)->index, ((match_ext*)el2)->index, 8 * sizeof(obliv int));
	obliv char ret = 1;
	obliv if (el1_is_less) { ret = -1; }
	return ret;*/
}



void full_mpfss_cuckoo(mpfss_cuckoo *m, match **matches, uint8_t **share ){

	debug("full_mpfss_cuckoo");
	obliv uint8_t **share1=calloc(m->t, sizeof(obliv uint8_t *));
	for (int i = 0; i < m->t; ++i){	
		obliv uint8_t *share1_part=calloc(memblocksize, sizeof(obliv uint8_t));
		feedOblivLLongArray((obliv uint64_t *)share1_part, (uint64_t *) share[i],  memblocksize/sizeof(uint64_t), 1);
		share1[i]=share1_part;
	}

	obliv uint8_t **share2=calloc(m->t, sizeof(obliv uint8_t *));
	for (int i = 0; i < m->t; ++i){	
		obliv uint8_t *share2_part=calloc(memblocksize, sizeof(obliv uint8_t));
		feedOblivLLongArray((obliv uint64_t *)share2_part, (uint64_t *) share[i],  memblocksize/sizeof(uint64_t), 2);
		share2[i]=share2_part;
	}


	obliv uint8_t **shareXor=calloc(m->t, sizeof(obliv uint8_t*));
	for (int i = 0; i < m->t; ++i){
		obliv uint8_t *shareXor_temp=calloc(1, memblocksize * sizeof(obliv uint8_t));
		shareXor[i]=shareXor_temp;
		for (int j = 0; j < memblocksize; ++j){
			shareXor[i][j]=share1[i][j]^share2[i][j];
		}
	}

	#ifdef DEBUG
		debug("share party 1\n");
		for (int i = 0; i < m->t; ++i){
			for (int ii = 0; ii < memblocksize; ++ii){
				int bucket_temp;
				revealOblivInt(&bucket_temp,share1[i][ii],0);
				printf("%d ", bucket_temp);
			}
			printf("\n");
		}

		debug("share party 2\n");
		for (int i = 0; i < m->t; ++i){
			for (int ii = 0; ii < memblocksize; ++ii){
				int bucket_temp;
				revealOblivInt(&bucket_temp,share2[i][ii],0);
				printf("%d ", bucket_temp);
			}
			printf("\n");
		}

		debug("xor of shares");
		for (int i = 0; i < m->t; ++i){
			for (int ii = 0; ii < memblocksize; ++ii){
				int bucket_temp;
				revealOblivInt(&bucket_temp,shareXor[i][ii],0);
				printf("%d ", bucket_temp);
			}
			printf("\n");
		}
	#endif

	for (int i = 0; i < m->t; ++i){
		free(share1[i]);
		free(share2[i]);
	}
	free(share1);
	free(share2);

	OcCopy cpy = ocCopyIntN(2); //set to size of a single element
	match_ext *matches_ext = calloc (m->b, sizeof(match_ext));
	
	obliv int *list=calloc(m->b*2,sizeof(obliv int));
	for (int i = 0; i < m->b; ++i){
		
		matches_ext[i].this_m=matches[i];
		matches_ext[i].index=feedOblivInt( matches[i]->val, 1);
		
		list[2*i+0]=matches_ext[i].index;
		list[2*i+1]=i;

		int index_temp;
		revealOblivInt(&index_temp,list[2*i+0],0);
		int bucket_temp;
		revealOblivInt(&bucket_temp,list[2*i+1],0);
		debug("index %d, batch_no %d", index_temp, bucket_temp);
	}

	osort_batcher(&cpy, (void *) list, (size_t)m->b, cmp_pair_by_key);
	//ocCopyRelease(&cpy); causes seg fault

	#ifdef DEBUG
		for (int i = 0; i < m->b; ++i){

			int index_temp;
			revealOblivInt(&index_temp,list[2*i+0],0);
			int bucket_temp;
			revealOblivInt(&bucket_temp,list[2*i+1],0);
			debug("index %d, batch_no %d", index_temp, bucket_temp);
		}
	#endif


	int not_used=m->b-m->t;

	for (int i = 0; i < m->b; ++i){
		obliv uint8_t *this_beta=calloc(memblocksize, sizeof(obliv uint8_t));

		obliv int index=list[i*2+0];
		obliv int bucket=list[i*2+1];
		int bucket_temp;
		revealOblivInt(&bucket_temp,list[2*i+1],0);
		//printf("bucket %d\n", bucket_temp );

		if(i>=not_used){
			int count=(i-not_used )%m->b;
			//printf("count %d\n",count );
			for (int j = 0;j < memblocksize; ++j){
				this_beta[j]=shareXor[count][j];   //TODO check for faster way to copy these bits
			}
		}
		matches_ext[bucket_temp].beta=this_beta;	
	}


	#ifdef DEBUG
		for (int i = 0; i < m->b; ++i){
			obliv uint8_t *this_beta=matches_ext[i].beta;
			for (int ii = 0; ii < memblocksize; ++ii){
				int part;
				revealOblivInt(&part,this_beta[ii],0);
				printf("%d ",part );
			}
			printf("\n");
		}
	#endif

}


void mpfss_vole_batch_cuckoo(void* args){

	yao_arguments *y_args= (yao_arguments *) args;
	mpfss_cuckoo *m=(mpfss_cuckoo *) y_args->m;
	int b=m->b;
	int size=m->size;
	int *bucket_lenghts=(int *) y_args->bucket_lenghts;
    match **matches =(match **) y_args->matches;
	int ** all_buckets_array= (int ** )y_args->all_buckets_array;
	uint8_t **beta_value_vector=(uint8_t **) y_args->beta_value_vector;
	uint8_t *beta_skalar=(uint8_t *) y_args->skalar;

	bool **dpf_vectors= (bool **)calloc(b, sizeof( bool *));
	uint8_t *** dpf_value_vectors= (uint8_t **)calloc(b, sizeof( uint8_t **));
	bool *mpfss_bit_vector=calloc(size, sizeof(bool));
	uint8_t **mpfss_value_vector=calloc(size, sizeof(uint8_t *));
	for (int i = 0; i < size; ++i){
		uint8_t * val=calloc(1,memblocksize);
		mpfss_value_vector[i]=val;
	}

	call_dpf_from_matches(	matches,dpf_vectors,dpf_value_vectors, 
							m, bucket_lenghts, y_args->set_beta , 
							beta_value_vector,beta_skalar,
							y_args->cprg);

	create_mpfss_vector_cuckoo(	mpfss_bit_vector, mpfss_value_vector, 
								dpf_vectors, dpf_value_vectors, 
								all_buckets_array, bucket_lenghts, size, b);

	for (int i = 0; i < b; ++i){
		free(dpf_vectors[i]);
		free(dpf_value_vectors[i]);
	}
	free(dpf_vectors);
	free(dpf_value_vectors);

	y_args->mpfss_bit_output=mpfss_bit_vector;
	y_args->mpfss_output=mpfss_value_vector;
}


void mpfss_batch_cuckoo(void* args){

	yao_arguments *y_args= (yao_arguments *) args;
	mpfss_cuckoo *m=(mpfss_cuckoo *) y_args->m;
	int b=m->b;
	int size=m->size;
	int *bucket_lenghts=(int *) y_args->bucket_lenghts;
    match **matches =(match **) y_args->matches;
	int ** all_buckets_array= (int ** )y_args->all_buckets_array;
	uint8_t **share=(uint8_t **) y_args->beta_value_vector;


	bool **dpf_vectors= (bool **)calloc(b, sizeof( bool *));
	uint8_t *** dpf_value_vectors= (uint8_t **)calloc(b, sizeof( uint8_t **));
	bool *mpfss_bit_vector=calloc(size, sizeof(bool));
	uint8_t **mpfss_value_vector=calloc(size, sizeof(uint8_t *));
	for (int i = 0; i < size; ++i){
		uint8_t * val=calloc(1,memblocksize);
		mpfss_value_vector[i]=val;
	}

	full_mpfss_cuckoo(m, matches, share );

	/*call_dpf_from_matches(	matches,dpf_vectors,dpf_value_vectors, 
							m, bucket_lenghts, y_args->set_beta , 
							beta_value_vector,beta_skalar,
							y_args->cprg);

	create_mpfss_vector_cuckoo(	mpfss_bit_vector, mpfss_value_vector, 
								dpf_vectors, dpf_value_vectors, 
								all_buckets_array, bucket_lenghts, size, b);*/

	for (int i = 0; i < b; ++i){
		free(dpf_vectors[i]);
		free(dpf_value_vectors[i]);
	}
	free(dpf_vectors);
	free(dpf_value_vectors);

	y_args->mpfss_bit_output=mpfss_bit_vector;
	y_args->mpfss_output=mpfss_value_vector;
}
