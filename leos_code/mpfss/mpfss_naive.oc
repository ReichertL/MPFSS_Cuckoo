#include <obliv.oh>
#include "mpfss_naive.h"

#include <fss.oh>


void mpfss_naive(void* args){

    protocolIO *io = (protocolIO*) args;
    size_t size=io->size;

    /*one block: 16 byte -> Blockmultiple allow longer */
    size_t blockmultiple=1;
    uint32_t truncated_levels=0;

    
    /* Creates new FSS instance
    	size_t size: size of input field
		size_t blockmultiple: How many Blocks are there in one entry -> 1 should be sufficient
		uint32_t truncated_levels:  The same as start level -> 0 should be a good value
		(only needed for fss_new , not for fss_cprg_new)
    */
    fss *my_fss;
    my_fss= fss_new(size, blockmultiple, truncated_levels);
	
	
    /*	The 'fss_getblockvector' function takes the
		value a as "index", and writes y^1 and y^2 as output into the location
		specified by the "local_output". Party 1 gets y^1 and party 2 gets y^2.

    	void *calloc(size_t nitems, size_t size)
    	calloc allocats memory and sets everything to zero.
    	Returns: Pointer to memory, NULL if request fails
    	nitems: no. of elements to be allocated
    	size: size of elements
    
    	Blocksize and blockmultiple inidicates the size of our output field:
    	Blocksize*blockmultiple = 2 ==> only 4 different y values possible.
    */
    uint8_t *local_output = calloc(size, BLOCKSIZE*blockmultiple);
  	bool *local_bit_output = calloc(size,  sizeof(bool));
  	

  	/*In DPF f(a)=b everywhere else the Function is 0. Index is equal to a.
  	The 'fss_getblockvector' function takes the value a as "index".
  	TODO: Should be a random number!
   	*/
   	int input_for_index=io->input; 
 	obliv int i_1=feedOblivInt(input_for_index, 1);
 	obliv int i_2=feedOblivInt(input_for_index, 2);

   	//obliv size_t index= i_1^i_2;

	obliv size_t index=2;

  	/* "Finally, you'll have noticed that there's no input for beta. That's because
	the final, correction stage of the FSS has not been performed, which means
	in effect that the DPF magnitude is random. This random magnitude is
	returned as a vector of obliv bytes, to the location specified by
	'activeblock_delta' "

	active_block_delta is a single Element of size: Blocksize*blockmultiple. But since these will be
	oblive bits a larger amount of bits need to be allocated. 
	active_block_delta will later on hold be the b value. This value is not preset in this 
	case as it will be set by the protocol at random.
	*/
  obliv uint8_t *active_block_delta = calloc(1, BLOCKSIZE*sizeof(obliv uint8_t)*blockmultiple);
	

    /*fss_getblockvector 
    	Calls fss gen and eval.
    	Generates a pair of keys and then evaluates the keys to produce
		two vectors y^1 and y^2 such that y^1_x xor y^2_x == b if x == a and
		y^1_x xor y^2_x == 0 otherwise.
		obliv uint8_t * active_block_delta: value of point function at point i
		uint8_t * local_output: 
		bool * local_bit_output: Will be 1 at corresponding index
		fss * fss: instance of fss
		obliv size_t index: index where point function =/= 0
	*/
    fss_getblockvector( 	active_block_delta, 
                            local_output, 
                            local_bit_output, 
                            my_fss, 
                           	index);
  // For debugging
  obliv int index_int= (obliv int) index;
  int index_non_obliv;
  revealOblivInt(&index_non_obliv, index_int, 0);
  printf("Index %d\n", index_non_obliv );

  printf(" local_output_bits: Party %d \n", io->party);
    for(int i = 0; i <size ; i++) {
        printf("%d ", local_bit_output[i]);  
  }
	printf(" \n");


  obliv bool *v1= calloc(size, sizeof(obliv bool));
  obliv bool *v2= calloc(size, sizeof(obliv bool));




    /* 	feedObliv<Typename>(typename v, int party)
    	Send obliv values to all parties.
    	tname can be: bool, char, int, short, long, long long, or float

    	==> void  feedOblivBoolArray(obliv bool  dest[],const bool  src[],size_t n, int party);;
    */
  feedOblivBoolArray(v1, local_bit_output, size, 1);
  feedOblivBoolArray(v2, local_bit_output, size, 2);

  bool *v1_non_obliv= calloc(size, sizeof( bool));
  bool *v2_non_obliv= calloc(size, sizeof( bool));

  revealOblivBoolArray(v1_non_obliv, v1, size, 0);
  revealOblivBoolArray(v2_non_obliv, v2, size, 0);

  for(int i = 0; i <size ; i++) {
    printf("%d ", v1_non_obliv[i]);  
  }
  printf(" \n");  

  for(int i = 0; i <size ; i++) {
    printf("%d ", v2_non_obliv[i]);  
  }
  printf(" \n");  

    obliv bool *dpf_obliv= calloc(size, sizeof(obliv bool));
    /*	Xor both local output vectors to generate an obliv vector*/
    *dpf_obliv=*v1 ^ *v2;
    bool *dpf= calloc(size, sizeof(bool));
    

    /* bool revealObliv<Tname>(tname* dest, obliv tname src, int party)
		Revealing oblive values to specified parties.
		Returns true if successful.
		When party=0: All parties will receive this value.
   
		==>bool  revealOblivBoolArray(bool dest[],  obliv bool src[],  size_t n,
               int party);
    */
  revealOblivBoolArray(dpf, dpf_obliv, size, 0);
	for(int i = 0; i <size ; i++) {
    printf("%d ", dpf[i]);	
	}
	printf(" \n");	

	/*Reveal b value */
	int activ_value=0;
  int *activ_value_ptr=&activ_value;
	revealOblivInt(activ_value_ptr, *active_block_delta, 0);
	printf("activ_value %d\n", activ_value );


  /*--------------------------------------------------------------*/

  /*  int *temp_v= calloc(size, BLOCKSIZE*sizeof(int)*blockmultiple);
    for(int i = 0; i <size ; i++) {
    		int temp=(int) local_output[i];
	      	temp_v[i]=temp;

	}

    obliv int *v1_int= calloc(size, BLOCKSIZE*sizeof(obliv int)*blockmultiple);
    obliv int *v2_int= calloc(size, BLOCKSIZE*sizeof(obliv int)*blockmultiple);

    feedOblivIntArray(v1_int, temp_v, size*BLOCKSIZE*blockmultiple, 1);
   	feedOblivIntArray(v2_int, temp_v, size*BLOCKSIZE*blockmultiple, 2);

    obliv uint8_t *dpf_obliv_int= calloc(size, BLOCKSIZE*sizeof(obliv uint8_t)*blockmultiple);
    *dpf_obliv_int=*v1 ^ *v2;


    uint8_t *dpf_int= calloc(size, BLOCKSIZE*blockmultiple);

    revealOblivCharArray(dpf_int, dpf_obliv_int, size*BLOCKSIZE*blockmultiple, 0);
	for(int i = 0; i <size; i++) {
	      printf("%zu ", dpf[i]);	
	}
	printf(" \n");	
*/


/*----------------------------------------------------------------*/









   	/*
	Does not seem to reveal the actual b value. Acual value in active_block_delta.
   	int b_value_hidden=local_output[a_value];
 
 	obliv int y1_x=feedOblivInt(local_output[b_value_hidden], 1);
 	obliv int y2_x=feedOblivInt(local_output[b_value_hidden], 2);

 	// Xor in C: "^"
 	obliv b_value_obliv= y1_x^y2_x;

  
  	int b_value=0;
  	int *b_value_ptr=&b_value;
	revealOblivInt(b_value_ptr, b_value_obliv, 0);
	printf("b_value %d\n", b_value )*/



    /* Freeing the allocated space.
    */
    free(active_block_delta);
    free(local_output);
    free(local_bit_output);
    free(v1);
    free(v2);
    
    //free(v1_int);
    //free(v2_int);
   
     free(dpf);
     free(dpf_obliv);



    


}
