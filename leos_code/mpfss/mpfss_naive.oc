#include <obliv.oh>
#include "mpfss_naive.h"
#include "dbg.h"

//#include <fss.oh>
#include <fss_cprg.oh>

/*one block: 16 byte -> Blockmultiple allow longer */
size_t blockmultiple=1;

/*  Creates management structure for MPFSS_naive.
    Input 
      t: Number of points in mpfss
      size: Size of the field the points can be taken from 
      party: Number of this party (either 1 or 2)
*/
mpfss * new_mpfss_naive( int t, size_t size,  int party){
  mpfss * mpfss = malloc(sizeof(mpfss));
  mpfss->t = t;
  mpfss->size = size;
  mpfss->party = party;
  return mpfss;

}

/*  Creates a Distributed Point Function using the fss_cprg.oh.
    Input
      size_t size: Size of the input field
      int input_for_index: Random value used to compute the x for the dpf
      int party: No of this party
      obliv uint8_t *values: Pointer to array of obliv integers
      int j : current run in loop (see loop in get_mpfss_vectors) 
      obliv bool **vector: pointer to a pointer 

    Output
      Writes obliv y value in values[j] 
      Returns the x value in form of an array of obliv bools. When the function 
      ended, vector will point to this specific array.   
      Return type: Void
*/
void dpf( size_t size, int input_for_index, int party, obliv uint8_t *values, int j, obliv bool **vector){
  log_info("-----------DPF Run: %d -----------\n",j );
    
    /*  fss_cprg * fss_cprg_new(size_t size, size_t blockmultiple) {
        Creates new FSS instance
        size_t size: size of input field
        size_t blockmultiple: How many Blocks are there in one entry -> 1 should be sufficient
		    uint32_t truncated_levels:  The same as start level -> 0 should be a good value
		    (only needed for fss_new , not for fss_cprg_new)
    */
  fss_cprg *my_fss;
	my_fss= fss_cprg_new(size, blockmultiple);

	
    /*	The 'fss_getblockvector' function takes the
		    value a as "index", and writes y^1 and y^2 as output into the location
		    specified by the "local_output". Party 1 gets y^1 and party 2 gets y^2.
      	void *calloc(size_t nitems, size_t size)
      	calloc allocats memory and sets everything to zero.
      	Returns: Pointer to memory, NULL if request fails
      	nitems: no. of elements to be allocated
      	size: size of elements
      	Blocksize and blockmultiple inidicates the size of our output field:
      	Blocksize*blockmultiple = 2 ==> only 4 different y values possible.
    */
  uint8_t *local_output = calloc(size, BLOCKSIZE*blockmultiple);
  bool *local_bit_output = calloc(size,  sizeof(bool));
  	

  	/*  In DPF f(a)=b everywhere else the Function is 0. Index is equal to a.
  	    The 'fss_getblockvector' function takes the value a as "index".
  	    TODO: Should be a random number!
   	*/
 	obliv int i_1=feedOblivInt(input_for_index, 1);
 	obliv int i_2=feedOblivInt(input_for_index, 2);

  obliv size_t index= (i_1^i_2 )% (int) size;

  	/* "Finally, you'll have noticed that there's no input for beta. That's because
	      the final, correction stage of the FSS has not been performed, which means
      	in effect that the DPF magnitude is random. This random magnitude is
      	returned as a vector of obliv bytes, to the location specified by
      	'active_block_delta' "

      	active_block_delta is a single Element of size: Blocksize*blockmultiple. But since these will be
      	oblive bits a larger amount of bits need to be allocated. 
      	active_block_delta will later on hold be the b value. This value is not preset in this 
      	case as it will be set by the protocol at random.
	   */
  obliv uint8_t *active_block_delta = calloc(1, BLOCKSIZE*sizeof(obliv uint8_t)*blockmultiple);
	

    /*  fss_getblockvector 
      	Calls fss gen and eval.
      	Generates a pair of keys and then evaluates the keys to produce
  		  two vectors y^1 and y^2 such that y^1_x xor y^2_x == b if x == a and
    		y^1_x xor y^2_x == 0 otherwise.
    		obliv uint8_t * active_block_delta: value of point function at point i
    		uint8_t * local_output: 
    		bool * local_bit_output: Will be 1 at corresponding index
    		fss * fss: instance of fss
    		obliv size_t index: index where point function =/= 0
  	*/
  fss_cprg_getblockvector( 	active_block_delta, 
                            local_output, 
                            local_bit_output, 
                            my_fss, 
                           	index);

    //Debug
  #ifdef NDEBUG
    obliv int index_int= (obliv int) index;
    int index_non_obliv;
    revealOblivInt(&index_non_obliv, index_int, 0);
    printf("index: %d\n", index_non_obliv );

    printf("local_output_bits (Party %d) \n", party);
      for(int i = 0; i <size ; i++) {
          printf("%d ", local_bit_output[i]);  
    }
  	printf(" \n");
  #endif


  obliv bool *v1= calloc(size, sizeof(obliv bool));
  obliv bool *v2= calloc(size, sizeof(obliv bool));


    /* 	feedObliv<Typename>(typename v, int party)
      	Send obliv values to all parties.
      	tname can be: bool, char, int, short, long, long long, or float
      	==> void  feedOblivBoolArray(obliv bool  dest[],const bool  src[],size_t n, int party);;
    */
  feedOblivBoolArray(v1, local_bit_output, size, 1);
  feedOblivBoolArray(v2, local_bit_output, size, 2);

  obliv bool *dpf_obliv= calloc(size, sizeof(obliv bool));
    /*	Xor both local output vectors to generate an obliv vector*/
  for(int i = 0; i <size ; i++) {
    dpf_obliv[i]=v1[i]^v2[i]; 
  }
  bool *dpf= calloc(size, sizeof(bool));
    

    /*  bool revealObliv<Tname>(tname* dest, obliv tname src, int party)
  		  Revealing oblive values to specified parties.
  		  Returns true if successful.
  		  When party=0: All parties will receive this value.
  		  ==>bool  revealOblivBoolArray(bool dest[],  obliv bool src[],  size_t n, int party);
    */

     //Debug
  #ifdef NDEBUG
    revealOblivBoolArray(dpf, dpf_obliv, size, 0);
    printf("dpf \n");
  	for(int i = 0; i <size ; i++) {
      printf("%d ", dpf[i]);	
  	}
  	printf(" \n");

  	int activ_value=0;
    int *activ_value_ptr=&activ_value;
  	revealOblivInt(activ_value_ptr, *active_block_delta, 0);
  	printf("activ_value %d\n", activ_value );
  #endif


    /*  
        Writing the return values to correct location
        ==>void * memcpy ( void * destination, const void * source, size_t num );
    */
  values[j]=*active_block_delta;
  *vector=dpf_obliv;


    /* Freeing the allocated space.*/
  free(active_block_delta);
  free(local_output);
  free(local_bit_output);
  free(v1);
  free(v2);
  free(dpf);
  fss_cprg_free(my_fss);
} 


/*  Interface for calling MPFSS. 
    Creates a obliv multi-point function. 
    Input: 
      mpfss *mpfss: Struct holing generall input information for the MPFSS
      obliv bool **vectors: Pointer to an array of pointers, which reference to oblive bool values. Length of array = size in mpfss struct.
      obliv uint8_t *values: Pointer to an array of obliv unit8_t values. Length of array = size in mpfss struct.
    
    Output:
      After function termination, vectors will hold a array of vectors which point to oblive bool values. 
      Each vector represents a non-obliv array with zeros everywhere, except when index equals to x of the dpf. At this position the non-obliv vector will hold a 1.
      Each vector from vectors represents one x value for a point of our multi-point function.  
      Values will hold the y values for each point. The y value for the x value stored in the i-th vector is located in values[i].
      Return type is void.
*/
void get_mpfss_vectors(mpfss *mpfss, obliv bool **vectors, obliv uint8_t *values ){
  size_t size=mpfss->size;
  int t=mpfss->t;
  debug("t %d\n", t );
  int party=mpfss->party;
  int input;

  obliv bool *vector;

  for (int j=0; j<t;j++){

      //TODO: get true randomization
      input =(j+party);
      debug("input %d\n", input );

      dpf(size,input,party, values, j,&vector);
      vectors[j]=vector;

        //Debug
      #ifdef NDEBUG
        bool *vdpf2= calloc(size, sizeof(bool));
        revealOblivBoolArray(vdpf2, vectors[j], size, 0);
        printf("dpf no. %d in get_mpfss_vectors\n", j);  
        for(int i = 0; i <size ; i++) {
          printf("%d ", vdpf2[i]);  
        }
        printf(" \n");

        int v_value=0;
        int *v_value_ptr=&v_value;
        revealOblivInt(v_value_ptr, values[j], 0);
        printf("activ_value in get_mpfss_vectors: %d\n", v_value );
      #endif

  }
  free(vector);
  free(vectors);
  free(values);

}


/*  Allows calling the mpfss function for an execYaoProtocol() call
    Input:
      void* args -> mpfss *mpfss

    Output
      No return type.
*/
void mpfss_naive(void* args){

  mpfss *mpfss = (mpfss*) args;
  
    /*Array of pointers: Length of pointers depend on system*/
  obliv bool **vectors= calloc(mpfss->t, sizeof(int *));
  obliv uint8_t *values = calloc(mpfss->t, BLOCKSIZE*sizeof(obliv uint8_t)*blockmultiple);
  get_mpfss_vectors(mpfss, vectors, values);

}