#include <stdlib.h>
#include <obliv.oh>
#include "dbg.h"
#include <string.h>
#include <math.h>
#include "mpfss_batch_codes.h"
#include <fss_cprg.oh>
#include <time.h>
#include <bcrandom.h>
#include "binary_search_tree.h"
#include "list_utils.c"
#include "linked_list.c"
#include "mpfss_naive.oc"




mpfss_batch * new_mpfss_batch( int t, size_t size, double epsilon, double s ){
  	mpfss_batch * mpfss = malloc(sizeof(mpfss_batch));
  	mpfss->t = t;
  	mpfss->size = size;
  	mpfss->epsilon= epsilon;
  	mpfss->s=s;
  	mpfss->d_exact=(1+s)*epsilon+1;
  	mpfss->m_exact= pow(t, 1+epsilon);
  	mpfss->m_rounded=round(mpfss->m_exact);
  	mpfss->d_rounded=round(mpfss->d_exact);
  	mpfss->p=1/pow(t,mpfss->d_exact);
  	mpfss->p_real=1/pow(t,mpfss->d_rounded);

  	#ifdef DEBUG
  	  	printf("t %d, size %d, epsilon %f, s %f \n",t,size, epsilon,s);
	  	printf("d %f, m %f, p %f\n",mpfss->d_exact, mpfss->m_exact, mpfss->p );
	  	printf("d %f, m %f, p %f\n",mpfss->d_rounded, mpfss->m_rounded, mpfss->p_real );
  	#endif

    return mpfss;

}

/*	
	Frees memory for a array of containing the heads of list data structures. 
	Lists have to be node_t lists.
*/
void free_nodet_list(node_t **heads, int m){
	for(int i=0; i<m; i++){
	  		node_t *current_H=heads[i];
	  		node_t *next_H;
	  		while(current_H!=NULL){
		  		next_H=current_H->next;
		  		free(current_H);
	  			current_H=next_H;
	  		}
	}

  	free(heads);
}

void create_indices(BCipherRandomGen *random_gen, int *indices_notobliv,  dllnode_t *head, int t , int size){
	
	head->is_head=1;
	head->val=-1;
	head->prev=NULL;
	dllnode_t *previous=head;
	unsigned long long rand; 
	for(int i=0; i<t; i++){
		rand= bcRandomInt(random_gen, (unsigned long long) size);
		indices_notobliv[i]=(int) rand;
	
		//filling indice list
		dllnode_t *current=calloc(1,sizeof(dllnode_t));
		current->val=(int) rand;
		current->prev=previous;
		previous->next=current;
		current->next=NULL;
		previous=current;
	}


  	#ifdef DEBUG
		printf("Indices before feedObliv\n");
		for(int i=0; i<t; i++){
	  		printf(" %d ", indices_notobliv[i]);
		}
		printf("\n");
	#endif

}

void create_batches_bst( mpfss_batch *mpfss, char *random_str[], dllnode_t **bt_roots, int *batch_len ){

  	double size=mpfss->size;
  	int m= mpfss->m_rounded;
  	int d= mpfss-> d_rounded;

	BCipherRandomGen *random_gen= newBCipherRandomGen(random_str);
	
  	dllnode_t *list_prev;


  	for(int i=0; i<m; i++){
  		batch_len[i]=0;
		//creating linked list holding roots of binary search trees
			struct bt_node *batch_root = NULL; 
		if(i==0){
			dllnode_t *first=create_head(batch_root, 0);
			list_prev=first;
			bt_roots[0]=first;
		}else{
			dllnode_t *element=insert_dllnode( list_prev, batch_root, i);
			list_prev=element;
			bt_roots[i]=element;
		}
  	}


  	for(int i=0; i<size; i++){
  		for(int j=0; j<d;j++){
  			
  			/*	bcrandom generates different values for both parties (even with same seed),
  			 	so they need to be broadcasted. 
  			*/
  			unsigned long long rand= bcRandomInt(random_gen, (unsigned long long) m);
  			int r_a;
  			int r_b;
  			r_a=ocBroadcastInt((int)rand, 1);
  			r_b=ocBroadcastInt((int)rand, 2);
			int r= (r_a+r_b)% m;

			int index_in_batch=batch_len[r];
			batch_len[r]=batch_len[r]+1;

			//create one big binary search tree: O(log(n) pro insert)
			dllnode_t *element =bt_roots[r]; 
			struct bt_node *batch_root=element->s;
			batchelement_t *batchelem=calloc(1, sizeof(batchelement_t));
			batchelem->index_in_batch=index_in_batch;
			batchelem->batch_no=r;
			batchelem->val=i;

			if(batch_root==NULL){
				element->s=insert( NULL, batchelem, i);

			}else{
				insert(batch_root,batchelem, i);
			}
  		}
  	}

  	#ifdef DEBUG

	  	printf("\n");
	  	int n=0;
	  	for(int i=0; i<m; i++){
	  		printf("Bucket %d: %d \n", i , batch_len[i] );
	  		n+=batch_len[i];
	  	}
	  	printf("N: %d\n", n );


		dllnode_t *batch_root=bt_roots[0];

  		while(true){
	  		printf("batch %d :", batch_root->val );
			struct bt_node *this_batch=batch_root->s;

	  		inorder(this_batch);
	  		printf("\n");



	  		if(batch_root->next==NULL){
	  			break;
  			}
  			batch_root=batch_root->next;
  		}
		printf("successfully created graph\n");
  	#endif
}



bool combine_batches_indices_bst(dllnode_t **bt_roots,  mpfss_batch *mpfss , int *indices_notobliv, pointinfo_t **matches, obliv int *indices ){
	int t=mpfss->t;
	int last_batch=false;
	dllnode_t *element =bt_roots[0]; 

	for(int j=0; j<t; j++){
		int index= indices_notobliv[j];
		//printf("index %d\n", index );
		while(!last_batch){
			//printf("element->val %d\n", element-> val);
			struct bt_node *batch_root=(struct bt_node *)element->s;
	  		struct bt_node *res=search(batch_root, index);
	  		//inorder(batch_root);
	  		//printf("\n");

	  		if(res==NULL && element->next==NULL){
	  			#ifdef DEBUG
  					printf("No available batch found for index %d \n", index );
  				#endif
	  			return false;
	  		}else if(res != NULL){
	  			//key was found in this batch

	  			node_t *this_node=(node_t *)res->s;
	  			
				pointinfo_t *p=calloc(1, sizeof(pointinfo_t));
			  	p->val=index;
			  	p->batch=element->val;
			  	int index_in_batch=this_node->index_in_batch;
				p->index_in_batch=index_in_batch;
				matches[j]=p;

				obliv int index_in_batch_obliv=feedOblivInt(index_in_batch, 1);
				indices[j]=index_in_batch;

				#ifdef DEBUG
	  				printf("index: %d batch_no: %d index_in_batch: %d \n", index, p->batch,p->index_in_batch);
	  			#endif
	  			dllnode_t *some_node=delink_dllnode(element);
	  			if(some_node==NULL){
	  				//All indices have been assigned
	  				#ifdef DEBUG
		  				printf("successfully matched indices and batches\n");
		  			#endif
	  				return true;
	  			}
				element=get_head(some_node);
				
	  			break;
	  		}

	  		element=element->next;

	  	}
  	}
  	return true;
}

/* 	Calls DPF for each batch. 
	Input: 
	  mpfss *mpfss: Struct holing generall input information for the MPFSS
	  obliv size_t *indices: Oblive array holding the indices (x values) for the multipoint function. Length of array: t.
	  obliv bool **vectors: Pointer to an array of pointers, which reference to obliv bool values. Length of array = size in mpfss struct.
	  obliv uint8_t *values: Pointer to an array of obliv unit8_t values. Length of array = size in mpfss struct.
	  int *batch_len: Array containing the lenght of each batch
	
	Output:
	  After function termination, vectors will hold a array of vectors which point to obliv bool values. 
	  Each vector represents a non-obliv array with zeros everywhere, except when index equals to x of the dpf. At this position the non-obliv vector will hold a 1.
	  Each vector from vectors represents one x value for a point of our multi-point function.  
	  Values will hold the y values for each point. The y value for the x value stored in the i-th vector is located in values[i].
	  Return type is void.
*/
void get_batch_vectors(mpfss_batch *mpfss, obliv int *indices, obliv bool **vectors, obliv uint8_t *values, int *batch_len){

  	int size=mpfss->size;
  	int m= mpfss->m_rounded;
 	obliv size_t index_in_batch;
  	obliv bool *batch_vector;
  	int batchsize;

  	for(int i=0; i<m;i++){
			int in;
			revealOblivInt(&in, index_in_batch, 0);
			printf("Index from obliv given by get_mpfss_vectors: %d\n",in );
			printf("batchsize %d\n",batchsize );

  		index_in_batch=indices[i];
  		batchsize=batch_len[i];
  		dpf(batchsize,index_in_batch, values, i,&batch_vector);
	  	vectors[i]=batch_vector;

		
		  #ifdef DEBUG
			printf("-----------Debug get_batch_vectors()-----------\n",i );
			int in;
			revealOblivInt(&in, index_in_batch, 0);
			printf("Index from obliv given by get_mpfss_vectors: %d\n",in );

			bool *vdpf2= calloc(size, sizeof(bool));
			revealOblivBoolArray(vdpf2, vectors[i], size, 0);
			printf("dpf #%d:               ", i);  
			for(int j = 0; j <size ; j++) {
			  printf("%d ", vdpf2[j]);  
			}
			printf(" \n");        
			free(vdpf2);


			int v_value=0;
			int *v_value_ptr=&v_value;
			revealOblivInt(v_value_ptr, values[i], 0);
			printf("activ_value in get_mpfss_vectors: %d\n", v_value );
		  #endif
  	}
}

/*	Function calls get_batch_vectors() and organizes the output.

*/
obliv bool *get_mpfss_vector_bc(mpfss_batch *mpfss, obliv int *indices, dllnode_t **bt_roots,  int *batch_len ){
  	int m= mpfss->m_rounded;
  	int size=mpfss->size;

  	obliv bool **vectors= calloc(m, sizeof(obliv bool *));
  	obliv uint8_t *values = calloc(m, BLOCKSIZE*sizeof(obliv uint8_t)*blockmultiple);
	get_batch_vectors(mpfss, indices, vectors, values, batch_len);

	#ifdef DEBUG
		printf("results\n");
	  	for(int i=0; i<m; i++){
	  				
	  		bool *vdpf2= calloc(size, sizeof(bool));
			revealOblivBoolArray(vdpf2, vectors[i], size, 0);
	  		for(int j=0; j<size; j++){
	  			printf("%d ", vdpf2[j]);  
			}
			printf(" \n");        
			free(vdpf2);
	  	}
  	#endif
  	
  	obliv bool *mpfss_vector= calloc(size, sizeof( obliv bool));

  	for (int i=0; i<m; i++){
  		int batchsize=batch_len[i];

  		dllnode_t *batch_root=bt_roots[i];
  		struct bt_node *this_batch=batch_root->s;
	  	batchelement_t **array=calloc(batch_len[i], sizeof(batchelement_t *));
	  	write_in_array(this_batch, array, 1);
	  	
	  	for(int j=0; j<batch_len[i]; j++){
	  		batchelement_t *elem=array[j];
	  		int x=elem->val;
	  		int index_in_batch= elem->index_in_batch;
	  		mpfss_vector[x]=mpfss_vector[x] ^ vectors[i][index_in_batch];
	  		
	  	}
  	}



  	free(vectors);
  	free(values);


}
/*  Example for creating a MPFSS Schema. Not Tested. 
	Callable from execYaoProtocol().
	Input:
	  void* args -> mpfss *mpfss

	Output
	  No return type.
*/
void mpfss_batch_codes(void* args){

  	mpfss_batch *mpfss = (mpfss_batch*) args;
  	int t=mpfss->t;
  	int size=mpfss->size;
  	int m= mpfss->m_rounded;

		/*Array of pointers: Length of pointers depend on system*/

  	//node_t **batches = calloc(m, sizeof(node_t *));
  	//batch_t *batch_head=calloc(1,sizeof(batch_t));
	dllnode_t **bt_roots = calloc(m, sizeof(dllnode_t*));
  	obliv int *indices = calloc(t, sizeof(obliv int));
  	int *batch_len=calloc(m, sizeof(int));

  	/*Generating Random Seed: ist das notwendig??*/
	BCipherRandomGen *random_gen= newBCipherRandomGen();
	unsigned long long rand= bcRandomInt(random_gen, pow(2,63));
	char random_str[50];
	sprintf(random_str, "%d",rand );

	/*Peer 1 generates indices at random*/
  	if(cp==1){
  		int *indices_notobliv = calloc(t, sizeof(int));
		dllnode_t *head=calloc(1,sizeof(dllnode_t));
		pointinfo_t **matches=calloc(t, sizeof(pointinfo_t *));


	   	create_indices(random_gen, indices_notobliv, head, t , size);
		//create_batches(mpfss, random_str, batches, batch_head, bt_roots);
		create_batches_bst(mpfss,random_str,bt_roots, batch_len );
		//combine_batches_indices(batches, mpfss, head, batch_head);
		combine_batches_indices_bst(bt_roots,  mpfss , indices_notobliv, matches, indices);
	  	//free(indices_notobliv);


	}else{
		create_batches_bst(mpfss,random_str,bt_roots, batch_len);
	}
	obliv bool *mpfss_vector= calloc(size, sizeof( obliv bool));
	mpfss_vector=get_mpfss_vector_bc(mpfss, indices, bt_roots, batch_len );

	/*free_nodet_list(batches, m);
  	free(vectors);
  	free(values);*/
}