#include <stdlib.h>
#include <obliv.oh>
#include "dbg.h"
#include <string.h>
#include <math.h>
#include "mpfss_batch_codes.h"
#include <fss_cprg.oh>
#include <time.h>
#include <bcrandom.h>

/*one block: 16 byte -> Blockmultiple allow longer */
size_t blockmultiple=1;

typedef struct node {

	//index of batch
    int right_node;
    int left_node;
    bool is_head;
    struct node * next;
} node_t;



mpfss_batch * new_mpfss_batch( int t, size_t size){
  	mpfss_batch * mpfss = malloc(sizeof(mpfss_batch));
  	mpfss->t = t;
  	mpfss->size = size;
    return mpfss;

}


void create_batches(obliv size_t *indices, mpfss_batch *mpfss, char *random_str[]){

  	double t = mpfss->t;
  	double size=mpfss->size;
  	double epsilon= 0.1;
  	//expansion factor
  	double s=4.0;
  	double d_exact=(1+s)*epsilon+1;
  	double m_exact= pow(t, 1+epsilon);
  	double m_r=round(m_exact);
  	double d_r=round(d_exact);
  	//probability of failure
  	double p=pow(t,-2*(d_exact-1));
  	double p_real=pow(t,-2*(d_r-1)); //d needs to be double

  	#ifdef DEBUG
  	  	printf("t %f, size %f, epsilon %f, s %f \n",t,size,epsilon,s);
	  	printf("d %f, m %f, p %f\n",d_exact, m_exact, p );
	  	printf("d %f, m %f, p %f\n",d_r, m_r, p_real );
  	#endif

  	int m= m_r;
  	int d=d_r;

  	//random number generator of obliv-c library  
  	obliv char i_A[20];
  	obliv char i_B[20];
  	obliv char obliv_key[20];
 	feedOblivCharArray(i_A, random_str, 20, 1);
 	feedOblivCharArray(i_B, random_str, 20, 2);
  	
  	/*for (int i = 0; i < 20; i++) {
 		obliv_key[i]=i_A[i]^i_B[i];
 	}*/
	const char key[30]="1234567890sdfghjkliu";
  	//revealOblivCharArray(key, i_A,20,0);
  
  	//printf("%s\n", key );

  	//Problem: Zufallszahlen sind nicht bei beiden gleich. Was machen?
  	//beide seiten sollen gleichen graph bekommen
  	//	1. in obliv erstellen
  	//	2. gleiche zufallszahlen garantieren
	BCipherRandomGen *random_gen= newBCipherRandomGen(&key);

  	node_t **heads = calloc(m, sizeof(node_t *));
  	node_t **tails = calloc(m, sizeof(node_t *));
  	int len_arr[m];


  	for(int i=0; i<m; i++){
		node_t *head = calloc(1,sizeof(node_t));
		head->is_head=true;
		heads[i]=head;
		tails[i]=head;
		len_arr[i]=0;
  	}

  	for(int i=0; i<size; i++){
  		for(int j=0; j<d;j++){
  			node_t *this_node=calloc(1, sizeof(node_t));
  			unsigned long long rand= bcRandomInt(random_gen, (unsigned long long) m);
  			int r_a;
  			int r_b;

  			/*	bcrandom generates different values for both parties (even with same seed),
  			 	so they need to be broadcasted. 
  			*/
  			r_a=ocBroadcastInt((int)rand, 1);
  			r_b=ocBroadcastInt((int)rand, 2);
			int r= (r_a+r_b)% m;

			this_node->right_node=r;
			this_node->left_node=i;

			this_node->is_head=false;
			node_t *current=tails[r];
			current->next=this_node;
			tails[r]= this_node;
			len_arr[r]=len_arr[r]+1;
  		}
  	}

  	#ifdef DEBUG
	  	printf("\n");
	  	for(int i=0; i<m; i++){
	  		printf("Bucket %d: %d \n ", i , len_arr[i] );
	  	}
	  	printf("successfully created graph\n");

	  	for(int i=0; i<m; i++){
	  		node_t *current=heads[i];
	  		while(current!=NULL){
	  			if(!current->is_head){
	  				printf(" ( %d , %d)", current->left_node, current->right_node );
	  			}
	  			current=current->next;
	  		}
	  	}
  	#endif

	// Free allocated memory  	

	for(int i=0; i<m; i++){
	  		node_t *current_H=heads[i];
	  		node_t *next_H;
	  		while(current_H!=NULL){
		  		next_H=current_H->next;
		  		free(current_H);
	  			current_H=next_H;
	  		}
	}

  	free(heads);
  	free(tails);
	
	/*	do: call dpf with that index, remove the covered index from the list
		additional overhead:
			z is the avarage batchsize
			O(t^2*z) -> can do a bit better, because after each batch indices will be one element shorter
			=> =(0.5*t^2*z)
		other solution:
		 create batches, recieve back a list containing (batches & indice in batch)
		 make lookup for each indice O(t*1) in obliv function
		 select for each indices a batch that has not been selected.
		 	-> use array with simple true-false 
		 	=>O(t*d)
		setup fails, if for one indice all available batches are already taken
	*/ 

}





/*  Example for creating a MPFSS Schema. Not Tested. 
	Callable from execYaoProtocol().
	Input:
	  void* args -> mpfss *mpfss

	Output
	  No return type.
*/
void mpfss_batch_codes(void* args){

  	mpfss_batch *mpfss = (mpfss_batch*) args;
  	int t=mpfss->t;
  	int size=mpfss->size;
		/*Array of pointers: Length of pointers depend on system*/
  	obliv bool **vectors= calloc(t, sizeof(int *));
  	obliv uint8_t *values = calloc(t, BLOCKSIZE*sizeof(obliv uint8_t)*blockmultiple);
  	int *indices_notobliv = calloc(t, sizeof(int));

		/*Creates pseudo-random indices*/
  	srand(time(NULL)); 
  	for(int i=0; i<t; i++){
		int r = rand(); 
		indices_notobliv[i]=r % (int)size;
  	}
  	indices_notobliv[1]=3;

  	#ifdef DEBUG
		printf("Indices before feedObliv\n");
		for(int i=0; i<t; i++){
	  		printf(" %d ", indices_notobliv[i]);
		}
		printf("\n");
  	#endif
  
		//feed indices one by one because target type is not int but size_t
  	obliv size_t *indices = calloc(t, BLOCKSIZE*sizeof(obliv size_t)*blockmultiple);
	for(int i=0; i<t; i++){
		obliv size_t k_obliv= feedOblivInt(indices_notobliv[i], 1);
		indices[i]=k_obliv;
	}
	char random_str[20];
	if(cp==1){
		strncpy(random_str, "1234567890sdfghjkliu00",20);
	}else{
		strncpy(random_str, "sdfghhjkkkwertzhnujmww",20);

	}
	printf("%s\n", random_str );
	create_batches(indices,mpfss, random_str);
	/*#ifdef DEBUG
		printf("results\n");
	  	for(int i=0; i<t; i++){
	  				
	  		bool *vdpf2= calloc(size, sizeof(bool));
			revealOblivBoolArray(vdpf2, vectors[i], size, 0);
	  		for(int j=0; j<size; j++){
	  			printf("%d ", vdpf2[j]);  
			}
			printf(" \n");        
			free(vdpf2);
	  	}
  	#endif
	*/


  	free(vectors);
  	free(values);
  	free(indices);
  	free(indices_notobliv);
}