#include <stdlib.h>
#include <obliv.oh>
#include "dbg.h"
#include <string.h>
#include <math.h>
#include <fss_cprg.oh>
#include <time.h>
#include <bcrandom.h>


#include "binary_search_tree.h"
#include "list_utils.h"
#include "linked_list.h"
#include "mpfss_naive.oh"

#include "mpfss_batch_codes.oh"




mpfss_batch * new_mpfss_batch( int t, size_t size, double epsilon, double s ){
  	mpfss_batch * mpfss = malloc(sizeof(mpfss_batch));
  	mpfss->t = t;
  	mpfss->size = size;
  	mpfss->epsilon= epsilon;
  	mpfss->s=s;
  	mpfss->d_exact=(1+s)*epsilon+1;
  	mpfss->m_exact= pow(t, 1+epsilon);
  	mpfss->m_rounded=round(mpfss->m_exact);
  	mpfss->d_rounded=round(mpfss->d_exact);
  	mpfss->p=1/pow(t,mpfss->d_exact);
  	mpfss->p_real=1/pow(t,mpfss->d_rounded);
	
  	debug("t %d, size %d, epsilon %f, s %f \n",t,size, epsilon,s);
	debug("d %f, m %f, p %f\n",mpfss->d_exact, mpfss->m_exact, mpfss->p );
	debug("d %f, m %f, p %f\n",mpfss->d_rounded, mpfss->m_rounded, mpfss->p_real );
  
    return mpfss;

}

/*	Uses the obliv-c random number generator to fill the array indices_notobliv
	with integer values. No value will be larger than size.
	Duplicate values can occur!

*/
void create_indices(BCipherRandomGen *random_gen, int *indices_notobliv, int t , int size){
	

	unsigned long long rand; 
	for(int i=0; i<t; i++){
		rand= bcRandomInt(random_gen, (unsigned long long) size);
		indices_notobliv[i]=(int) rand;
	}


  	#ifdef DEBUG
		printf("Indices before feedObliv\n");
		for(int i=0; i<t; i++){
	  		printf(" %d ", indices_notobliv[i]);
		}
		printf("\n");
	#endif

}

void create_batches(mpfss_batch *mpfss, BCipherRandomGen *random_gen,   int *batch_len, batchelement_t ***inputfield){
  	double size=mpfss->size;
  	int m= mpfss->m_rounded;
  	int d= mpfss-> d_rounded;

  	#ifdef DEBUG
  		dllnode_t **heads=calloc(m, sizeof(dllnode_t));
  		dllnode_t **tails=calloc(m, sizeof(dllnode_t));
  	#endif

	for(int i=0; i<size; i++){

		batchelement_t **member_of_batches=calloc(d, sizeof(batchelement_t *));

		inputfield[i]=member_of_batches;
  		for(int j=0; j<d;j++){
  			
  			/*	bcrandom generates different values for both parties (even with same seed),
  			 	so they need to be broadcasted. 
  			*/
  			unsigned long long rand= bcRandomInt(random_gen, (unsigned long long) m);
  			int r_a;
  			int r_b;
  			r_a=ocBroadcastInt((int)rand, 1);
  			r_b=ocBroadcastInt((int)rand, 2);
			int r= (r_a+r_b)% m;

			int index_in_batch=batch_len[r];
			batch_len[r]=batch_len[r]+1;

			batchelement_t *batchelem=calloc(1, sizeof(batchelement_t));
			batchelem->index_in_batch=index_in_batch;
			batchelem->batch_no=r;
			batchelem->val=0;
			member_of_batches[j]=batchelem;


			#ifdef DEBUG
				if(heads[r]==NULL){
					dllnode_t *first=create_head(batchelem, i);
					heads[r]=first;
					tails[r]=first;
				}else{
					dllnode_t *element=insert_dllnode( tails[r], batchelem, i);		
					tails[r]=element;
				}
			#endif

  		}
  	}

  	#ifdef DEBUG
  		for (int i = 0; i < m; ++i){
  	
  			printf("Batch no %d : ", i);
  			dllnode_t *current= heads[i];
  			while(current!=NULL){
  				printf("%d ", current->val);
  				current=current->next;
  			}
  			printf("\n");
  		}
  		free(heads);
  		free(tails);

  	#endif
}

bool combine_batches_indices(batchelement_t ***inputfield, mpfss_batch *mpfss , int *indices_notobliv, pointinfo_t **matches){
	int t=mpfss->t;
  	double size=mpfss->size;
  	int m= mpfss->m_rounded;
  	int d= mpfss-> d_rounded;
	int last_batch=false;
	int *batches_used=calloc(m, sizeof(int));

	for(int j=0; j<t; j++){
		int index= indices_notobliv[j];
		
		batchelement_t **member_of_batches= inputfield[index];
		int i=0;
		bool matched=false;
		while(i<d){
			batchelement_t *batchelem=member_of_batches[i];
			int batch_no=batchelem->batch_no;
			//if this bachtelement has not been matched with a batch yet
			if(batchelem->val==0 && batches_used[batch_no]==0){
				pointinfo_t *p=calloc(1, sizeof(pointinfo_t));
				p->val=index;
				p->batch=batch_no;
				p->index_in_batch=batchelem->index_in_batch;
				matches[p->batch]=p;

				batches_used[batch_no]=1;
				matched=true;
 				debug("Index: %d batch_no: %d index_in_batch: %d \n", index, p->batch,p->index_in_batch);
 				batchelem->val=1;
				break;
			}
			i++;
		}
		if(!matched){
			log_info("Matching indices and batches failed for index %d.\n", index);
			return false;
		}
  	}

  	for (int i = 0; i < m; ++i)
  	{
  		if(batches_used[i]==0){
  			pointinfo_t *p=calloc(1, sizeof(pointinfo_t));
			p->val=-1;
			p->batch=i;
			p->index_in_batch=-1;
			matches[i]=p;
  		}
  	}
	log_info("Successfully matched indices and batches\n");
  	return true;
}


/*	Will call combine_batches_indices_bst at most three times.
	Permutes indices_notobliv between the calls.
	If successful once, returns true.
	If never successful, return false.
*/
bool try_combine_batches_indices(BCipherRandomGen *random_gen, batchelement_t ***inputfield, mpfss_batch *mpfss , int *indices_notobliv, pointinfo_t **matches){
	
	int max=3;
	bool succ=false;
	for(int i=0; i<max;i++){
		//debug("Try: %d",i );
		succ= combine_batches_indices(inputfield, mpfss , indices_notobliv, matches);
		if(succ){
			return true;	
		}else{
			bcRandomPermutation(random_gen, indices_notobliv, (size_t) mpfss->t);

		}

	}
	log_err("Matching indices and batches failed %d times\n", max);
	return false;
}

/* 	Calls DPF for each batch. 
	Input: 
	  mpfss *mpfss: Struct holing generall input information for the MPFSS
	  obliv size_t *indices: Oblive array holding the indices (x values) for the multipoint function. Length of array: t.
	  obliv bool **vectors: Pointer to an array of pointers, which reference to obliv bool values. Length of array = size in mpfss struct.
	  obliv uint8_t *values: Pointer to an array of obliv unit8_t values. Length of array = size in mpfss struct.
	  int *batch_len: Array containing the lenght of each batch
	
	Output:
	  After function termination, vectors will hold a array of vectors which point to obliv bool values. 
	  Each vector represents a non-obliv array with zeros everywhere, except when index equals to x of the dpf. At this position the non-obliv vector will hold a 1.
	  Each vector from vectors represents one x value for a point of our multi-point function.  
	  Values will hold the y values for each point. The y value for the x value stored in the i-th vector is located in values[i].
	  Return type is void.
*/
void get_batch_vectors(mpfss_batch *mpfss, pointinfo_t **matches, obliv bool **vectors, obliv uint8_t *values, int *batch_len){

  	int size=mpfss->size;
  	int m= mpfss->m_rounded;
  	int t=mpfss->t;
 	obliv size_t index_in_batch;
  	obliv bool *batch_vector;
  	int batchsize;

  	for(int i=0; i<m;i++){
  		int j=0;
  		if(ocCurrentParty()==1){
  			j=matches[i]->index_in_batch;
  			if(j==-1){
  				printf("empty batch!\n");
  				//j=batch_len[i]+1;
  			}

  		}
  		index_in_batch=feedOblivInt(j,1);
		batchsize=batch_len[i];

		//This is a hack, maybe there are better ways
		if(batchsize<=1){
			batchsize=2;
		}

		#ifdef DEBUG
			int in;
			revealOblivInt(&in, index_in_batch, 0);
			printf("Index from obliv given by get_mpfss_vectors: %d\n",in );
			printf("batchsize %d\n",batchsize );
		#endif

  		dpf(batchsize,index_in_batch, values, i,&batch_vector);
	  	vectors[i]=batch_vector;

		
		  #ifdef DEBUG
			printf("-----------Debug get_batch_vectors()-----------\n",i );
			int in;
			revealOblivInt(&in, index_in_batch, 0);
			printf("Index from obliv given by get_mpfss_vectors: %d\n",in );

			bool *vdpf2= calloc(batchsize, sizeof(bool));
			revealOblivBoolArray(vdpf2, batch_vector, batchsize, 0);
			printf("dpf #%d:               ", i);  
			for(int j = 0; j <batchsize ; j++) {
			  printf("%d ", vdpf2[j]);  
			}
			printf(" \n");        
			free(vdpf2);


			int v_value=0;
			int *v_value_ptr=&v_value;
			revealOblivInt(v_value_ptr, values[i], 0);
			printf("activ_value in get_mpfss_vectors: %d\n", v_value );
		  #endif
  	}
}

/*	Function calls get_batch_vectors() and organizes the output.
*/
void get_mpfss_vector_bc(mpfss_batch *mpfss,obliv uint8_t *values, obliv bool *mpfss_vector, pointinfo_t **matches, batchelement_t ***inputfield,  int *batch_len ){
  	int m= mpfss->m_rounded;
  	int size=mpfss->size;
  	int d= mpfss-> d_rounded;

  	obliv bool **vectors= calloc(m, sizeof(obliv bool *));
	get_batch_vectors(mpfss, matches, vectors, values, batch_len);

	#ifdef DEBUG
		printf("results\n");
	  	for(int i=0; i<m; i++){
	  				
	  		bool *vdpf2= calloc(batch_len[i], sizeof(bool));
			revealOblivBoolArray(vdpf2, vectors[i], batch_len[i], 0);
	  		for(int j=0; j<batch_len[i]; j++){
	  			printf("%d ", vdpf2[j]);  
			}
			printf(" \n");        
			free(vdpf2);
	  	}
  	#endif
  	

	/*	Going trough each batch and figuring out for each element in batch the values from the encrypted vector
	 	Then OR that value with the corresponding value of an array of length 'size', called mpfss_vector.
	  */
  	for (int i=0; i<size; i++){
  		
		batchelement_t **member_of_batches= inputfield[i];
	  	int j=0;
	  	while(j<d){

			batchelement_t *elem=member_of_batches[j];

			int batch_no=elem->batch_no;
	  		int index_in_batch= elem->index_in_batch;
	  		mpfss_vector[i]=mpfss_vector[i] | vectors[batch_no][index_in_batch];
	  		
	  		j++;
	  	}
  	}

	#ifdef DEBUG
		bool *vdpf2= calloc(size, sizeof(bool));
		revealOblivBoolArray(vdpf2, mpfss_vector, size, 0);
		printf("Final Revealed MPFSS Value\n");

		for(int i=0; i<size;i++){
			printf("%d ", vdpf2[i]);
		}
		free(vdpf2);
		printf("\n");
		for(int i=0;i<m;i++){
			int v_value=0;
			int *v_value_ptr=&v_value;
			revealOblivInt(v_value_ptr, values[i], 0);
			printf("%d ", v_value );
		}
		printf("\n");
	#endif




  	free(vectors);

}

/*  Example for creating a MPFSS Schema. Not Tested. 
	Callable from execYaoProtocol().
	Input:
	  void* args -> mpfss *mpfss

	Output
	  No return type.
*/
void mpfss_batch_codes(void* args){

  	mpfss_batch *mpfss = (mpfss_batch*) args;
  	int t=mpfss->t;
  	int size=mpfss->size;
  	int m= mpfss->m_rounded;
	int d= mpfss->d_rounded;
	
	int *indices_notobliv = calloc(t, sizeof(int));
  	int *batch_len=calloc(m, sizeof(int));
	pointinfo_t **matches=calloc(t, sizeof(pointinfo_t *));
	int success =false;
	batchelement_t ***inputfield=calloc(size, sizeof(batchelement_t **));
  	BCipherRandomGen *random_gen= newBCipherRandomGen();

	/*Peer 1 generates indices at random*/
  	if(ocCurrentParty()==1){
	   	create_indices(random_gen, indices_notobliv, t , size);
		create_batches(mpfss, random_gen, batch_len,inputfield);
		success=try_combine_batches_indices(random_gen, inputfield, mpfss , indices_notobliv, matches);

  		ocBroadcastInt(success, 1);
  		printf("success %d\n", success);
  		if(!success){
  			exit(1);
  		}

	}else{
		create_batches(mpfss, random_gen, batch_len,inputfield);
	
		int ok=3;
		while(!( ok==1 || ok==0)){
			ok= ocBroadcastInt(1, 1);
		}
		if(ok==0){
			log_err("Matching indices and batches failed multiple times.\n");
			exit(1);
		}
	}	

  	obliv uint8_t *values = calloc(m, BLOCKSIZE*sizeof(obliv uint8_t)*block_no);
	obliv bool *mpfss_vector= calloc(size, sizeof( obliv bool));
	get_mpfss_vector_bc(mpfss, values, mpfss_vector,  matches, inputfield, batch_len );

	#ifdef DEBUG
		bool *vdpf2= calloc(size, sizeof(bool));
		revealOblivBoolArray(vdpf2, mpfss_vector, size, 0);
		printf("Final Revealed MPFSS Value\n");

		for(int i=0; i<size;i++){
			printf("%d ", vdpf2[i]);
		}
		free(vdpf2);
		printf("\n");
		for(int i=0;i<m;i++){
			int v_value=0;
			int *v_value_ptr=&v_value;
			revealOblivInt(v_value_ptr, values[i], 0);
			printf("%d ", v_value );
		}
		printf("\n");
	#endif


  	free(random_gen);
  	free(indices_notobliv);
  	free(batch_len);
  	for (int i = 0; i < size; ++i)
  	{		
  		batchelement_t **member_of_batches= inputfield[i];
  		free(member_of_batches);
  	}
 	free(inputfield);
  	free(mpfss_vector);
  	for (int i = 0; i < t; ++i)
  	{
  		pointinfo_t *p=matches[i];
  		free(p);
  	}
  	free(matches);
}
