#include <obliv.oh>
#include <bcrandom.h>
#include <stdlib.h>
#include <fss.oh>

#include "dbg.h"
#include "util.h"
#include "mpfss_naive.h"
#include "mpfss_naive.oh"



/*  Creates management structure for MPFSS_naive. Tested.
	Input 
	t: Number of points in mpfss
	size: Size of the field the points can be taken from 

*/
mpfss * new_mpfss_naive( int t, size_t size){
  mpfss * mpfss = malloc(sizeof(mpfss));
  mpfss->t = t;
  mpfss->size = size;
  return mpfss;

}

/*  Creates a Distributed Point Function using the fss.oh. Tested.
	Input
	  size_t size: Size of the input field
	  obliv size_t index: Used as x value for the point function
	  obliv uint8_t *values: Pointer to array of obliv integers
	  int j : current run in loop (see loop in get_mpfss_vector) 
	  obliv bool **vector: pointer to a pointer 

	Output
	  Writes obliv y value in values[j] 
	  Returns the x value in form of an array of obliv bools. When the function 
	  ended, vector will point to this specific array.   
	  Return type: Void
*/
void dpf( size_t size, obliv size_t index, obliv uint8_t *values, int j,  bool **vector){
	log_info("-----------DPF Run: %d -----------\n",j );

	int index_non_obliv;
	revealOblivInt(&index_non_obliv, (obliv int) index, 0);
	log_info(" call to dpf with size %zu, index %d\n", size, index_non_obliv);


	/*  fss * fss(size_t size, size_t block_no) {
		Creates new FSS instance
		size_t size: size of input field
		size_t block_no: How many Blocks are there in one entry -> 1 should be sufficient
			uint32_t truncated_levels:  The same as start level -> 0 should be a good value
			(only needed for fss_new , not for fss_new)
	*/
	fss *my_fss;
	my_fss= fss_new(size, block_no,1 );

	
	/*	The 'fss_getblockvector' function takes the
			value a as "index", and writes y^1 and y^2 as output into the location
			specified by the "local_output". Party 1 gets y^1 and party 2 gets y^2.
		void *calloc(size_t nitems, size_t size)
		calloc allocats memory and sets everything to zero.
		Returns: Pointer to memory, NULL if request fails
		nitems: no. of elements to be allocated
		size: size of elements
		Blocksize and block_no inidicates the size of our output field:
		Blocksize*block_no = 2 ==> only 4 different y values possible. ???
	*/

	uint8_t *local_output = calloc(size,BLOCKSIZE*sizeof(uint8_t));
	bool *local_bit_output = calloc(size,  sizeof(bool)); 


	/* "Finally, you'll have noticed that there's no input for beta. That's because
		  the final, correction stage of the FSS has not been performed, which means
		in effect that the DPF magnitude is random. This random magnitude is
		returned as a vector of obliv bytes, to the location specified by
		'active_block_delta' "

		active_block_delta is a single Element of size: Blocksize*block_no. But since these will be
		obliv bits a larger amount of bits need to be allocated. 
		active_block_delta will later on hold be the b value. This value is not preset in this 
		case as it will be set by the protocol at random.
	   */
  obliv uint8_t *active_block_delta = calloc(1, BLOCKSIZE*sizeof(obliv uint8_t));


	

	/*  fss_getblockvector 
		Calls fss gen and eval.
		Generates a pair of keys and then evaluates the keys to produce
		  two vectors y^1 and y^2 such that y^1_x xor y^2_x == b if x == a and
			y^1_x xor y^2_x == 0 otherwise.
			obliv uint8_t * active_block_delta: value of point function at point i
			uint8_t * local_output: 
			bool * local_bit_output: Will be 1 at corresponding index
			fss * fss: instance of fss
			obliv size_t index: In DPF f(a)=b everywhere else the Function is 0. Index is equal to a.
	*/
	fss_getblockvector( 	active_block_delta, 
							local_output, 
							local_bit_output, 
							my_fss, 
							index);
	
		//Debug
	  #ifdef DEBUG

		obliv bool *v1= calloc(size, sizeof(obliv bool));
		obliv bool *v2= calloc(size, sizeof(obliv bool));

		/* 	feedObliv<Typename>(typename v, int party)
			Send obliv values to all parties.
			tname can be: bool, char, int, short, long, long long, or float
			==> void  feedOblivBoolArray(obliv bool  dest[],const bool  src[],size_t n, int party);;
		*/
		feedOblivBoolArray(v1, local_bit_output, size, 1);
		feedOblivBoolArray(v2, local_bit_output, size, 2);

		obliv bool *dpf_obliv= calloc(size, sizeof(obliv bool));
		/*	Xor both local output vectors to generate an obliv vector*/
		for(int i = 0; i <size ; i++) {
			dpf_obliv[i]=v1[i]^v2[i]; 
		}
	  
		bool *dpf= calloc(size, sizeof(bool));
		
		/*  bool revealObliv<Tname>(tname* dest, obliv tname src, int party)
			  Revealing obliv values to specified parties.
			  Returns true if successful.
			  When party=0: All parties will receive this value.
			  ==>bool  revealOblivBoolArray(bool dest[],  obliv bool src[],  size_t n, int party);
		*/
		revealOblivBoolArray(dpf, dpf_obliv, size, 0);
		char buff [(int)size * sizeof(int) + 100];
		sprintf(buff, "dpf                    ", j);  
		for(int i = 0; i <size ; i++) {
			char r[1+ sizeof(int)];
			sprintf(r, " %d", dpf[i]);		
		  strcat(buff, r );  
		}
		debug("%s\n",buff);


		int activ_value=0;
		int *activ_value_ptr=&activ_value;
		revealOblivInt(activ_value_ptr, *active_block_delta, 0);
		debug("activ_value %d\n", activ_value );
		

		free(v1);
		free(v2);
		free(dpf);
		free(dpf_obliv);
	#endif

	/*  
		Writing the return values to correct location
		==>void * memcpy ( void * destination, const void * source, size_t num );
	*/
  values[j]=*active_block_delta;
  *vector=local_bit_output;

	/* Freeing the allocated space.*/
  free(active_block_delta);

  free(local_output);
  fss_free(my_fss);
	
} 


/*  Interface for calling MPFSS. Tested. 
	Creates a obliv multi-point function. 
	Input: 
	  mpfss *mpfss: Struct holing generall input information for the MPFSS
	  obliv size_t *indices: Oblive array holding the indices (x values) for the multipoint function. Length of array: t.
	  obliv bool **vector: Pointer to an array of obliv bool values. Length of array = size in mpfss struct.
	  obliv uint8_t *values: Pointer to an array of obliv unit8_t values. Length of array = size in mpfss struct.
	
	Output:
	  After function termination, vectors will hold a array of vectors which point to obliv bool values. 
	  Each vector represents a non-obliv array with zeros everywhere, except when index equals to x of the dpf. At this position the non-obliv vector will hold a 1.
	  Each vector from vectors represents one x value for a point of our multi-point function.  
	  Values will hold the y values for each point. The y value for the x value stored in the i-th vector is located in values[i].
	  Return type is void.
*/
void get_mpfss_vector(mpfss *mpfss, obliv size_t *indices, bool *vector, obliv uint8_t *values ){
  size_t size=mpfss->size;
  int t=mpfss->t;
  debug("t %d\n", t );
  obliv size_t index;
  
  

  for (int j=0; j<t;j++){
	  bool *this_vector;
	  index=indices[j];
	  dpf(size,index, values, j,&this_vector);

	  for (int i = 0; i < size; i++){
		vector[i]=vector[i]^this_vector[i];
	  }

		//Debug
	  #ifdef DEBUG
		debug("Debug get_mpfss_vector()\n",j );


		int v_value=0;
		int *v_value_ptr=&v_value;
		revealOblivInt(v_value_ptr, values[j], 0);
		debug("activ_value in get_mpfss_vector: %d\n", v_value );
		obliv bool *v1= calloc(size, sizeof(obliv bool));
		obliv bool *v2= calloc(size, sizeof(obliv bool));
		feedOblivBoolArray(v1, this_vector, size, 1);
		feedOblivBoolArray(v2, this_vector, size, 2);

		obliv bool *dpf_obliv= calloc(size, sizeof(obliv bool));
		for(int i = 0; i <size ; i++) {
			dpf_obliv[i]=v1[i]^v2[i]; 
		}

		bool *vdpf2= calloc(size, sizeof(bool ));
		revealOblivBoolArray(vdpf2, dpf_obliv, size, 0);

		char buff [(int)size * sizeof(int) + 100];
		sprintf(buff, "vector round #%d:               ", j);  
		for(int i = 0; i <size ; i++) {
			char r[1+ sizeof(int)];
			sprintf(r, " %d", vdpf2[i]);		
		  strcat(buff, r );  
		}
		debug("%s\n",buff);


		feedOblivBoolArray(v1, vector, size, 1);
		feedOblivBoolArray(v2, vector, size, 2);
		for(int i = 0; i <size ; i++) {
			dpf_obliv[i]=v1[i]^v2[i]; 
		}

		char buff [(int)size * sizeof(int) + 100];
		sprintf(buff, "Zwischenergebnis:   		 	 ");  

		bool *vdpf3= calloc(size, sizeof(bool));
		revealOblivBoolArray(vdpf3, dpf_obliv, size, 0);
		for(int j=0; j<size; j++){  

			char r[1+ sizeof(int)];
			sprintf(r, " %d", vdpf3[j]);		
		  strcat(buff, r );  
		}
		debug("%s\n",buff);

		free(vdpf3);      
		free(vdpf2);
		free(v1);
		free(v2);
		free(dpf_obliv);
	  #endif


	  free(this_vector);
  }
}





/*  Example for creating a MPFSS Schema. No unit test for this function. 
	Callable from execYaoProtocol().
	Input:
	  void* args -> mpfss *mpfss

	Output
	  No return type.
*/
void mpfss_naive(void* args){

	mpfss *mpfss = (mpfss*) args;
	int t=mpfss->t;
	int size=mpfss->size;
		/*Array of pointers: Length of pointers depend on system*/
	bool *vector=calloc(size, sizeof(bool));
	obliv uint8_t *values = calloc(t, BLOCKSIZE*sizeof(obliv uint8_t));
	int *indices_notobliv = calloc(t, sizeof(int ));
			
		if(ocCurrentParty()==1){
			create_indices( indices_notobliv, t , size);
		}
	
		//feed indices one by one because target type is not int but size_t
	obliv size_t *indices = calloc(t, BLOCKSIZE*sizeof(obliv size_t));
	for(int i=0; i<t; i++){
		obliv size_t k_obliv= feedOblivInt(indices_notobliv[i], 1);
		indices[i]=k_obliv;
	}

	//TODO: Write function that will return only a single vector !
	get_mpfss_vector(mpfss, indices, vector, values);

	#ifdef DEBUG
		debug("results\n");
		
		obliv bool *v1= calloc(size, sizeof(obliv bool));
		obliv bool *v2= calloc(size, sizeof(obliv bool));
		feedOblivBoolArray(v1, vector, size, 1);
		feedOblivBoolArray(v2, vector, size, 2);

		obliv bool *dpf_obliv= calloc(size, sizeof(obliv bool));
		for(int i = 0; i <size ; i++) {
			dpf_obliv[i]=v1[i]^v2[i]; 
		}    


		bool *vdpf2= calloc(size, sizeof(bool ));
		revealOblivBoolArray(vdpf2, dpf_obliv, size, 0);
		char buff [(int)size * sizeof(int) + 100];
		for(int j = 0; j <size ; j++) {
			char r[1+ sizeof(int)];
			sprintf(r, " %d", vdpf2[j]);		
		  strcat(buff, r );  
		}
		debug("%s\n",buff);

		free(vdpf2);
		free(v1);
		free(v2);
		free(dpf_obliv);

	#endif


	free(mpfss); 	
	free(vector);
	free(values);
	free(indices);
	free(indices_notobliv);
}
