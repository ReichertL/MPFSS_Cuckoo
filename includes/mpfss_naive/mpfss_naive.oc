#include <bcrandom.h>
#include <stdlib.h>

#include <obliv.oh>
#include <obliv_float_ops.h>
#include <fss.oh>
#include <fss_cprg.oh>
#include <floram_util.h>
#include <inttypes.h>

#include "dbg.h"
#include "util.h"
#include "mpfss_naive.h"
#include "mpfss_naive.oh"



/*  Creates management structure for MPFSS_naive. Tested.
	Input 
	t: Number of points in mpfss
	size: Size of the field the points can be taken from 

*/
mpfss * new_mpfss_naive( int t, size_t size){
  mpfss * mpfss = malloc(sizeof(mpfss));
  mpfss->t = t;
  mpfss->size = size;
  return mpfss;

}


/*	Input:
	Similar to dpf but takes a value for beta: f(index)=beta (0 everywhere else).
	Beta ist an array of  uint8_t values (length: memblocksize)
		e.g.:  uint8_t this_beta[16]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50};
		Neither local_bit_output nor local_output need to be initialized beforehand.
	Output:
	This function will write a bit representation of the dpf into local_bit_output.
	The dpf with values (each element has length of memblocksize) is stored in local_output.
	Works for blockmultiple==1

*/

void dpf_with_beta( size_t size, 
							size_t index_non_obliv,
							obliv uint8_t *beta, 
							int j,  
							bool **local_bit_output_ret, 
							uint8_t **local_output_ret,
							bool cprg_set){

	debug("-----------DPF Run: %d -----------\n",j );
	OcCopy memblockcpy=ocCopyCharN(memblocksize);

	
	obliv size_t index=feedOblivInt( index_non_obliv, 1);

	obliv int correction_bit;
	if(index_non_obliv==-1){
		correction_bit=feedOblivInt( 1,1);
	}else{
		correction_bit=feedOblivInt( 0,1);
	}

	#ifdef DEBUG
		if(ocCurrentParty()==1){
			debug(" call to dpf with size %zu, index %d\n", size, index_non_obliv);
		}
		
		debug("beta");
		for (int ii = 0; ii < memblocksize; ++ii){
			int part;
			revealOblivInt(&part,beta[ii],0);
			printf("%d ",part );
		}
		printf("\n");
		
	#endif 
		
	void *my_fss;
	if(cprg_set){
		my_fss= (fss_cprg *)fss_cprg_new(size, block_no);
	}else{
		my_fss= (fss *)fss_new(size, block_no,1);
	}

	uint8_t *local_output=(uint8_t *)calloc(size, memblocksize*sizeof(uint8_t));
	bool *local_bit_output=(bool *) calloc(size, sizeof(bool));
	//floram_pma(&local_output, 16, size* memblocksize);
	//floram_pma(&local_bit_output, 16, size * sizeof(bool));


	obliv uint8_t *active_block_delta = calloc(1, memblocksize * sizeof(obliv uint8_t));

  	if(cprg_set){
		fss_cprg_getblockvector( 	active_block_delta, 
									local_output, 
									local_bit_output, 
									my_fss, 
									index);
	}else{
		fss_getblockvector( 		active_block_delta, 
									local_output, 
									local_bit_output, 
									my_fss, 
									index);
	}

	//----Correction-----------------------

	obliv uint8_t *temp=calloc(1, memblockcpy.eltsize);
	uint8_t *temp_local=malloc(memblocksize);
	
	for (int i = 0; i < memblocksize; ++i){
		temp[i]= active_block_delta[i] ^ beta[i];
	}

	for (size_t ii = 0; ii < memblocksize/sizeof(uint64_t); ii++){
		revealOblivLLong(&((uint64_t *)temp_local)[ii], ((obliv uint64_t *)temp)[ii], 2);
		revealOblivLLong(&((uint64_t *)temp_local)[ii], ((obliv uint64_t *)temp)[ii], 1);
	}

	for (size_t ii = 0; ii< size; ii++) {
		for (size_t jj = 0; jj < memblocksize; jj++) {
			local_output[ii * memblocksize + jj]^=(local_bit_output[ii] * temp_local[jj]);
		}
	}

	free(temp);
	free(temp_local);


	//----Correction for undefinded behaviour of fss for index==-1

	obliv uint8_t *local_bit_output_obliv1=calloc(size, sizeof(obliv uint8_t));
	feedOblivBoolArray((obliv uint64_t *)local_bit_output_obliv1, (uint64_t *) local_bit_output,  size, 1);
	obliv uint8_t *local_bit_output_obliv2=calloc(size, sizeof(obliv uint8_t));
	feedOblivBoolArray((obliv uint64_t *)local_bit_output_obliv2, (uint64_t *) local_bit_output,  size, 2);
	
	obliv bool *dpf_obliv= calloc(size, sizeof(obliv bool));
	obliv int sum=0;
	obliv int index_corretion;
	for(int i = 0; i <size ; i++) {
		dpf_obliv[i]=local_bit_output_obliv1[i]^local_bit_output_obliv2[i]; 
		sum=sum+dpf_obliv[i];
		obliv if(dpf_obliv[i]==1){
			index_corretion=i;
		}
	}
	
	int sum_no;
	revealOblivInt(&sum_no, sum,1);
	int ic_no;
	revealOblivInt(&ic_no, index_corretion,1);
	if(index_non_obliv==-1 && sum_no>0){
		local_bit_output[ic_no]=!local_bit_output[ic_no];
		debug("Undefined behavior in fss. Correction of local_bit_output was needed.");
	}	

	free(local_bit_output_obliv1);
	free(local_bit_output_obliv2);
	free(dpf_obliv);

	//----Return Values-------------------
	

	*local_output_ret=local_output;
	*local_bit_output_ret=local_bit_output;

	//-----Debug--------------------------
	#ifdef DEBUG

		obliv bool *v1= calloc(size, sizeof(obliv bool));
		obliv bool *v2= calloc(size, sizeof(obliv bool));

		feedOblivBoolArray(v1, local_bit_output, size, 1);
		feedOblivBoolArray(v2, local_bit_output, size, 2);

		obliv bool *dpf_obliv= calloc(size, sizeof(obliv bool));
		/*	Xor both local output vectors to generate an obliv vector*/
		for(int i = 0; i <size ; i++) {
			dpf_obliv[i]=v1[i]^v2[i]; 
		}
		free(v1);
		free(v2);	  
		bool *dpf= calloc(size, sizeof(bool));

		revealOblivBoolArray(dpf, dpf_obliv, size, 0);
		char buff [(int)size * sizeof(int) + 100];
		sprintf(buff, "dpf\n", j);  
		for(int i = 0; i <size ; i++) {
			char r[1+ sizeof(int)];
			sprintf(r, " %d", dpf[i]);		
		  strcat(buff, r );  
		}
		debug("%s\n",buff);
		free(dpf_obliv);
		free(dpf);

		//------------------------------------------------------------

		uint8_t *local_output_1=calloc(1, size* memblocksize*sizeof(obliv uint8_t));
		uint8_t *local_output_2=calloc(1, size* memblocksize*sizeof(obliv uint8_t));
		ocBroadcastLLongArray((uint64_t *)local_output_1, (uint64_t *)local_output, size*memblocksize/sizeof(uint64_t), 1);
		ocBroadcastLLongArray((uint64_t *)local_output_2, (uint64_t *)local_output,size*memblocksize/sizeof(uint64_t),  2);
		uint8_t *dpf_with_beta=(uint8_t *) calloc(size, memblocksize*sizeof(uint8_t));
		//floram_pma(&dpf_with_beta, 16, size* memblocksize);
		for (size_t ii = 0; ii< size; ii++) {
			for (size_t jj = 0; jj < memblocksize; jj++) {
				uint8_t xor=  local_output_1[ii * memblocksize + jj]^ local_output_2[ii * memblocksize + jj];
				dpf_with_beta[ii * memblocksize + jj]=xor;
			}
		}
		free(local_output_1);
		free(local_output_2);

		char *buff = (char *) calloc((int)size *memblocksize+100, sizeof(int));
		sprintf(buff, "dpf_with_values %d\n", j);  
		for(int i = 0; i <size ; i++) {
			for (int j=0;j<memblocksize; ++j){
				char r[1+ sizeof(int)];
				sprintf(r, " %d", dpf_with_beta[i * memblocksize + j]);		
			  	strcat(buff, r );  
			}	
			char *eof="\n";	
			strcat(buff, eof );
		}
		debug("%s\n",buff);
		free(buff);
		free(dpf_with_beta);

		//----------------------------------------------------------------------------------
		/*char *buff = (char *) calloc( memblocksize+100, sizeof(int));
		sprintf(buff, "activ_value \n");  
		for (int i = 0; i < memblocksize; ++i){
			int xx=0;
			revealOblivInt(&xx, active_block_delta[i],0);
			char r[1+ sizeof(int)];
			sprintf(r, " %d", xx);		
			strcat(buff, r );  
		}
		debug("%s\n",buff);
		free(buff);*/


	#endif

	free(active_block_delta);
	if(cprg_set){
		fss_cprg_free(my_fss);
	}else{
	 	fss_free(my_fss);
	}	
} 

/*	Input:
	Same as dpf but called with different parameter.
	Beta is random.
	Neither local_bit_output, active_block_delta nor local_output need to be initialized beforehand.

	Output:
	This function will write a bit representation of the dpf into local_bit_output.
	The dpf with values (each element has length of memblocksize) is stored in local_output.
	The magnitude (beta) is written active_block_delta.
	Works for blockmultiple==1
	
*/
void dpf_proper( size_t size,  size_t index_non_obliv, obliv uint8_t **active_block_delta_ret, int j,  bool **local_bit_output_ret, uint8_t **local_output_ret, bool cprg_set){
	debug("-----------DPF Run: %d -----------\n",j );
	debug(" call to dpf with size %zu, index %d\n", size, index_non_obliv);

	obliv size_t index=feedOblivInt( index_non_obliv, 1);

	OcCopy memblockcpy=ocCopyCharN(memblocksize);

	uint8_t *beta_non_obliv=calloc(memblocksize, sizeof(uint8_t));
	if(index_non_obliv==-1){
		for (int i = 0; i < memblocksize; ++i){
			beta_non_obliv[i]=0;
		}
	}else{
		for (int i = 0; i < memblocksize; ++i){
			beta_non_obliv[i]=1;
		}	}
	obliv uint8_t *beta=calloc(1, memblocksize * sizeof(obliv uint8_t));
	feedOblivLLongArray((obliv uint64_t *)beta, (uint64_t *) beta_non_obliv,  memblocksize/sizeof(uint64_t), 1);

	void *my_fss;
	if(cprg_set){
		my_fss= (fss_cprg *)fss_cprg_new(size, block_no);
	}else{
		my_fss= (fss *)fss_new(size, block_no,1);
	}
	
	uint8_t *local_output;
	bool *local_bit_output;
	floram_pma(&local_output, 16, size* memblocksize);
	floram_pma(&local_bit_output, 16, size * sizeof(bool));

  	obliv uint8_t *active_block_delta = calloc(1, memblocksize * sizeof(obliv uint8_t));

  	if(cprg_set){
		fss_cprg_getblockvector( 	active_block_delta, 
									local_output, 
									local_bit_output, 
									my_fss, 
									index);
	}else{
		fss_getblockvector( 		active_block_delta, 
									local_output, 
									local_bit_output, 
									my_fss, 
									index);
	}

	//----Correction-----------------------


	obliv uint8_t *temp=calloc(1, memblockcpy.eltsize);
	uint8_t *temp_local=malloc(memblocksize);
	
	for (int i = 0; i < memblocksize; ++i){
		temp[i]= active_block_delta[i] * beta[i];
	}

	for (size_t ii = 0; ii < memblocksize/sizeof(uint64_t); ii++){
		revealOblivLLong(&((uint64_t *)temp_local)[ii], ((obliv uint64_t *)temp)[ii], 2);
		revealOblivLLong(&((uint64_t *)temp_local)[ii], ((obliv uint64_t *)temp)[ii], 1);
	}

	for (size_t ii = 0; ii< size; ii++) {
		for (size_t jj = 0; jj < memblocksize; jj++) {
			local_output[ii * memblocksize + jj]^=(local_bit_output[ii] * temp_local[jj]);
		}
	}

	free(temp);
	free(temp_local);


	//----Correction for undefinded behaviour of fss for index==-1

	obliv uint8_t *local_bit_output_obliv1=calloc(size, sizeof(obliv uint8_t));
	feedOblivBoolArray((obliv uint64_t *)local_bit_output_obliv1, (uint64_t *) local_bit_output,  size, 1);
	obliv uint8_t *local_bit_output_obliv2=calloc(size, sizeof(obliv uint8_t));
	feedOblivBoolArray((obliv uint64_t *)local_bit_output_obliv2, (uint64_t *) local_bit_output,  size, 2);
	
	obliv bool *dpf_obliv= calloc(size, sizeof(obliv bool));
	obliv int sum=0;
	obliv int index_corretion;
	for(int i = 0; i <size ; i++) {
		dpf_obliv[i]=local_bit_output_obliv1[i]^local_bit_output_obliv2[i]; 
		sum=sum+dpf_obliv[i];
		obliv if(dpf_obliv[i]==1){
			index_corretion=i;
		}
	}
	
	int sum_no;
	revealOblivInt(&sum_no, sum,1);
	int ic_no;
	revealOblivInt(&ic_no, index_corretion,1);
	if(index_non_obliv==-1 && sum_no>0){
		local_bit_output[ic_no]=!local_bit_output[ic_no];
		debug("Undefined behavior in fss. Correction of local_bit_output was needed.");
	}	

	free(local_bit_output_obliv1);
	free(local_bit_output_obliv2);
	free(dpf_obliv);
	

	//----Return Values-------------------
	

	*local_output_ret=local_output;
	*local_bit_output_ret=local_bit_output;
	*active_block_delta_ret=active_block_delta;


	//-----Debug--------------------------
	  #ifdef DEBUG

		obliv bool *v1= calloc(size, sizeof(obliv bool));
		obliv bool *v2= calloc(size, sizeof(obliv bool));

		/* 	feedObliv<Typename>(typename v, int party)
			Send obliv values to all parties.
			tname can be: bool, char, int, short, long, long long, or float
			==> void  feedOblivBoolArray(obliv bool  dest[],const bool  src[],size_t n, int party);;
		*/
		feedOblivBoolArray(v1, local_bit_output, size, 1);
		feedOblivBoolArray(v2, local_bit_output, size, 2);

		obliv bool *dpf_obliv= calloc(size, sizeof(obliv bool));
		/*	Xor both local output vectors to generate an obliv vector*/
		for(int i = 0; i <size ; i++) {
			dpf_obliv[i]=v1[i]^v2[i]; 
		}
		free(v1);
		free(v2);	  
		bool *dpf= calloc(size, sizeof(bool));
		
		/*  bool revealObliv<Tname>(tname* dest, obliv tname src, int party)
			  Revealing obliv values to specified parties.
			  Returns true if successful.
			  When party=0: All parties will receive this value.
			  ==>bool  revealOblivBoolArray(bool dest[],  obliv bool src[],  size_t n, int party);
		*/
		revealOblivBoolArray(dpf, dpf_obliv, size, 0);
		char buff [(int)size * sizeof(int) + 100];
		sprintf(buff, "dpf                    ", j);  
		for(int i = 0; i <size ; i++) {
			char r[1+ sizeof(int)];
			sprintf(r, " %d", dpf[i]);		
		  strcat(buff, r );  
		}
		debug("%s\n",buff);
		free(dpf_obliv);
		free(dpf);
		//------------------------------------------------------------

		uint8_t *local_output_1=calloc(1, size* memblocksize*sizeof(obliv uint8_t));
		uint8_t *local_output_2=calloc(1, size* memblocksize*sizeof(obliv uint8_t));
		ocBroadcastLLongArray((uint64_t *)local_output_1, (uint64_t *)local_output, size*memblocksize/sizeof(uint64_t), 1);
		ocBroadcastLLongArray((uint64_t *)local_output_2, (uint64_t *)local_output,size*memblocksize/sizeof(uint64_t),  2);
		uint8_t *dpf_with_beta;
		floram_pma(&dpf_with_beta, 16, size* memblocksize);
		for (size_t ii = 0; ii< size; ii++) {
			for (size_t jj = 0; jj < memblocksize; jj++) {
				uint8_t xor=  local_output_1[ii * memblocksize + jj]^ local_output_2[ii * memblocksize + jj];
				dpf_with_beta[ii * memblocksize + jj]=xor;
			}
		}
		free(local_output_1);
		free(local_output_2);

		char *buff = (char *) calloc((int)size *memblocksize+100, sizeof(int));
		sprintf(buff, "dpf with values \n", j);  
		for(int i = 0; i <size ; i++) {
			for (int j=0;j<memblocksize; ++j){
				char r[1+ sizeof(int)];
				sprintf(r, " %d", dpf_with_beta[i * memblocksize + j]);		
			  	strcat(buff, r );  
			}	
			char *eof="\n";	
			strcat(buff, eof );
		}
		debug("%s\n",buff);
		free(buff);
		free(dpf_with_beta);



		//--------------------------------------------------------------
		char *buff = (char *) calloc(memblocksize+100, sizeof(int));
		sprintf(buff, "active_block_delta       ");  
		for (int i = 0; i < memblocksize; ++i){
			uint8_t activ_value=0;
			revealOblivInt(&activ_value, active_block_delta[i], 0);
			char r[1+ sizeof(int)];
			sprintf(r, " %d", activ_value);		
			strcat(buff, r );  
		}
		debug("%s\n",buff);
		free(buff);
		#endif

	if(cprg_set){
		fss_cprg_free(my_fss);
	}else{
	 	fss_free(my_fss);
	}
	free(beta);
	free(beta_non_obliv);
}


/*  Interface for calling MPFSS. Tested. 
	Creates a obliv multi-point function. 
	Input: 
	  mpfss *mpfss: Struct holing generall input information for the MPFSS
	  obliv size_t *indices: Oblive array holding the indices (x values) for the multipoint function. Length of array: t.
	  obliv bool **vector: Pointer to an array of obliv bool values. Length of array = size in mpfss struct.
	  obliv uint8_t *values: Pointer to an array of obliv unit8_t values. Length of array = size in mpfss struct.
	
	Output:
	  After function termination, vectors will hold a array of vectors which point to obliv bool values. 
	  Each vector represents a non-obliv array with zeros everywhere, except when index equals to x of the dpf. At this position the non-obliv vector will hold a 1.
	  Each vector from vectors represents one x value for a point of our multi-point function.  
	  Values will hold the y values for each point. The y value for the x value stored in the i-th vector is located in values[i].
	  Return type is void.
*/
void get_mpfss_vector(mpfss *mpfss, int *indices_notobliv, bool *vector){
  //int memblocksize=BLOCKSIZE*block_no;
  size_t size=mpfss->size;
  int t=mpfss->t;
  debug("t %d\n", t );
  obliv size_t index;
  
  for (int j=0; j<t;j++){

	  obliv uint8_t *active_block_delta_ret;
	  bool *local_bit_output_ret;
	  uint8_t *local_output_ret;
	  int index_non_obliv=indices_notobliv[j];
	  
	  dpf_proper(	(size_t) size,  
	  				(size_t) index_non_obliv, 
	  				&active_block_delta_ret, 
	  				j,  
	  				&local_bit_output_ret, 
	  				&local_output_ret, 
	  				true);

	  for (int i = 0; i < size; i++){
		vector[i]=vector[i]^local_bit_output_ret[i];
	  }

		//Debug
	  #ifdef DEBUG
		debug("Debug get_mpfss_vector()\n",j );

		
		obliv bool *v1= calloc(size, sizeof(obliv bool));
		obliv bool *v2= calloc(size, sizeof(obliv bool));
		feedOblivBoolArray(v1, local_bit_output_ret, size, 1);
		feedOblivBoolArray(v2, local_bit_output_ret, size, 2);

		obliv bool *dpf_obliv= calloc(size, sizeof(obliv bool));
		for(int i = 0; i <size ; i++) {
			dpf_obliv[i]=v1[i]^v2[i]; 
		}

		bool *vdpf2= calloc(size, sizeof(bool ));
		revealOblivBoolArray(vdpf2, dpf_obliv, size, 0);

		char *buff= calloc(size, sizeof(int)*sizeof(char)+100);
		sprintf(buff, "vector round #%d:               ", j);  
		for(int i = 0; i <size ; i++) {
			char r[1+ sizeof(int)];
			sprintf(r, " %d", vdpf2[i]);		
		  strcat(buff, r );  
		}
		debug("%s\n",buff);
		free(buff);

		feedOblivBoolArray(v1, vector, size, 1);
		feedOblivBoolArray(v2, vector, size, 2);
		for(int i = 0; i <size ; i++) {
			dpf_obliv[i]=v1[i]^v2[i]; 
		}

		char *buff= calloc(size, sizeof(int)*sizeof(char)+100);
		sprintf(buff, "Zwischenergebnis:   		 	 ");  

		bool *vdpf3= calloc(size, sizeof(bool));
		revealOblivBoolArray(vdpf3, dpf_obliv, size, 0);
		for(int j=0; j<size; j++){  

			char r[1+ sizeof(int)];
			sprintf(r, " %d", vdpf3[j]);		
		  strcat(buff, r );  
		}
		debug("%s\n",buff);
		free(buff);

		free(vdpf3);      
		free(vdpf2);
		free(v1);
		free(v2);
		free(dpf_obliv);
	  #endif


	  free(local_bit_output_ret);
	  free(local_output_ret);
	  free(active_block_delta_ret);
  }
}





/*  Example for creating a MPFSS Schema. No unit test for this function. 
	Callable from execYaoProtocol().
	Input:
	  void* args -> mpfss *mpfss

	Output
	  No return type.
*/
void mpfss_naive(void* args){

	mpfss *mpfss = (mpfss*) args;
	int t=mpfss->t;
	int size=mpfss->size;
		/*Array of pointers: Length of pointers depend on system*/
	bool *vector=calloc(size, sizeof(bool));
	int *indices_notobliv = calloc(t, sizeof(int ));
			
		if(ocCurrentParty()==1){
			create_indices( indices_notobliv, t , size);
		}
	

	//TODO: Write function that will return only a single vector !
	get_mpfss_vector(mpfss, indices_notobliv, vector);

	#ifdef DEBUG
		debug("results\n");
		
		obliv bool *v1= calloc(size, sizeof(obliv bool));
		obliv bool *v2= calloc(size, sizeof(obliv bool));
		feedOblivBoolArray(v1, vector, size, 1);
		feedOblivBoolArray(v2, vector, size, 2);

		obliv bool *dpf_obliv= calloc(size, sizeof(obliv bool));
		for(int i = 0; i <size ; i++) {
			dpf_obliv[i]=v1[i]^v2[i]; 
		}    


		bool *vdpf2= calloc(size, sizeof(bool ));
		revealOblivBoolArray(vdpf2, dpf_obliv, size, 0);
		char *buff= calloc(size, sizeof(int)*sizeof(char)+10);
		for(int j = 0; j <size ; j++) {
			char r[1+ sizeof(int)];
			sprintf(r, " %d", vdpf2[j]);		
		  	strcat(buff, r );

		}
		debug("%s\n",buff);
		free(buff);

		free(vdpf2);
		free(v1);
		free(v2);
		free(dpf_obliv);
	#endif


	free(mpfss); 	
	free(vector);
	free(indices_notobliv);
}
